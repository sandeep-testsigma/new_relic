{"version":3,"file":"agent-session-CcuyTkuw.js","sources":["../../node_modules/@newrelic/browser-agent/src/common/timer/timer.js","../../node_modules/@newrelic/browser-agent/src/common/timer/interaction-timer.js","../../node_modules/@newrelic/browser-agent/src/common/session/session-entity.js","../../node_modules/@newrelic/browser-agent/src/common/storage/local-storage.js","../../node_modules/@newrelic/browser-agent/src/features/utils/agent-session.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class Timer {\n  constructor (opts, ms) {\n    if (!opts.onEnd) throw new Error('onEnd handler is required')\n    if (!ms) throw new Error('ms duration is required')\n    this.onEnd = opts.onEnd\n    this.initialMs = ms\n    this.startTimestamp = Date.now()\n\n    this.timer = this.create(this.onEnd, ms)\n  }\n\n  create (cb, ms) {\n    if (this.timer) this.clear()\n    return setTimeout(() => cb ? cb() : this.onEnd(), ms || this.initialMs)\n  }\n\n  clear () {\n    clearTimeout(this.timer)\n    this.timer = null\n  }\n\n  end () {\n    this.clear()\n    this.onEnd()\n  }\n\n  isValid () {\n    return this.initialMs - (Date.now() - this.startTimestamp) > 0\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Timer } from './timer'\nimport { subscribeToVisibilityChange } from '../window/page-visibility'\nimport { debounce } from '../util/invoke'\nimport { isBrowserScope } from '../constants/runtime'\n\nexport class InteractionTimer extends Timer {\n  constructor (opts, ms) {\n    super(opts, ms)\n    this.onPause = typeof opts.onPause === 'function' ? opts.onPause : () => { /* noop */ }\n    this.onRefresh = typeof opts.onRefresh === 'function' ? opts.onRefresh : () => { /* noop */ }\n    this.onResume = typeof opts.onResume === 'function' ? opts.onResume : () => { /* noop */ }\n\n    /** used to double-check LS state at resume time */\n    this.readStorage = opts.readStorage\n\n    // used by pause/resume\n    this.remainingMs = undefined\n\n    if (!opts.refreshEvents) opts.refreshEvents = ['click', 'keydown', 'scroll']\n\n    // the abort controller is used to \"reset\" the event listeners and prevent them from duplicating when new sessions are created\n    try {\n      this.abortController = new AbortController()\n    } catch (e) {\n      // this try-catch can be removed when IE11 is completely unsupported & gone\n    }\n\n    if (isBrowserScope && opts.ee) {\n      if (opts.ee) {\n        this.ee = opts.ee\n        const debouncedRefresh = debounce(this.refresh.bind(this), 500, { leading: true })\n        this.refreshHandler = (evts) => {\n          if (opts.refreshEvents.includes(evts?.[0]?.type)) {\n            debouncedRefresh()\n          }\n        }\n        opts.ee.on('fn-end', this.refreshHandler)\n      }\n\n      // watch for the vis state changing.  If the page is hidden, the local inactivity timer should be paused\n      // if the page is brought BACK to visibility and the timer hasnt \"naturally\" expired, refresh the timer...\n      // this is to support the concept that other tabs could be experiencing activity.  The thought would be that\n      // \"backgrounded\" tabs would pause, while \"closed\" tabs that \"reopen\" will just instantiate a new SessionEntity class if restored\n      // which will do a \"hard\" check of the timestamps.\n\n      // NOTE -- this does not account for 2 browser windows open side by side, blurring/focusing between them\n      // IF DEEMED necessary, more event handling would be needed to account for this.\n      subscribeToVisibilityChange((state) => {\n        if (state === 'hidden') this.pause()\n        // vis change --> visible is treated like a new interaction with the page\n        else this.resume()\n      }, false, false, this.abortController?.signal)\n    }\n  }\n\n  abort () {\n    this.clear()\n    this.abortController?.abort()\n\n    if (this.refreshHandler) {\n      this.ee.removeEventListener('fn-end', this.refreshHandler)\n      this.refreshHandler = this.ee = null\n    }\n  }\n\n  pause () {\n    this.onPause()\n    clearTimeout(this.timer)\n    this.remainingMs = this.initialMs - (Date.now() - this.startTimestamp)\n  }\n\n  resume () {\n    try {\n      const lsData = this.readStorage()\n      const obj = typeof lsData === 'string' ? JSON.parse(lsData) : lsData\n      if (isExpired(obj.expiresAt) || isExpired(obj.inactiveAt)) this.end()\n      else {\n        this.refresh()\n        this.onResume() // emit resume event after state updated\n      }\n    } catch (err) {\n      this.end()\n    }\n    function isExpired (timestamp) {\n      return Date.now() > timestamp\n    }\n  }\n\n  refresh (cb, ms) {\n    this.clear()\n    this.timer = this.create(cb, ms)\n    this.startTimestamp = Date.now()\n    this.remainingMs = undefined\n    this.onRefresh()\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { generateRandomHexString } from '../ids/unique-id'\nimport { warn } from '../util/console'\nimport { stringify } from '../util/stringify'\nimport { ee } from '../event-emitter/contextual-ee'\nimport { Timer } from '../timer/timer'\nimport { isBrowserScope } from '../constants/runtime'\nimport { DEFAULT_EXPIRES_MS, DEFAULT_INACTIVE_MS, MODE, PREFIX, SESSION_EVENTS, SESSION_EVENT_TYPES } from './constants'\nimport { InteractionTimer } from '../timer/interaction-timer'\nimport { wrapEvents } from '../wrap/wrap-events'\nimport { getModeledObject } from '../config/configurable'\nimport { handle } from '../event-emitter/handle'\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../features/metrics/constants'\nimport { FEATURE_NAMES } from '../../loaders/features/features'\nimport { windowAddEventListener } from '../event-listener/event-listener-opts'\nimport { LOGGING_MODE } from '../../features/logging/constants'\n\n// this is what can be stored in local storage (not enforced but probably should be)\n// these values should sync between local storage and the parent class props\nconst model = {\n  value: '',\n  inactiveAt: 0,\n  expiresAt: 0,\n  updatedAt: Date.now(),\n  sessionReplayMode: MODE.OFF,\n  sessionReplaySentFirstChunk: false,\n  sessionTraceMode: MODE.OFF,\n  traceHarvestStarted: false,\n  loggingMode: LOGGING_MODE.OFF,\n  serverTimeDiff: null, // set by TimeKeeper; \"undefined\" value will not be stringified and stored but \"null\" will\n  custom: {},\n  numOfResets: 0\n}\n\nexport class SessionEntity {\n  /**\n   * Create a self-managing Session Entity. This entity is scoped to the agent identifier which triggered it, allowing for multiple simultaneous session objects to exist.\n   * There is one \"namespace\" an agent can store data in LS -- NRBA_{key}. If there are two agents on one page, and they both use the same key, they could overwrite each other since they would both use the same namespace in LS by default.\n   * The value can be overridden in the constructor, but will default to a unique 16 character hex string\n   * expiresMs and inactiveMs are used to \"expire\" the session, but can be overridden in the constructor. Pass 0 to disable expiration timers.\n   */\n  constructor (opts) {\n    const { agentIdentifier, key, storage } = opts\n\n    if (!agentIdentifier || !key || !storage) {\n      throw new Error(`Missing required field(s):${!agentIdentifier ? ' agentID' : ''}${!key ? ' key' : ''}${!storage ? ' storage' : ''}`)\n    }\n    this.agentIdentifier = agentIdentifier\n    this.storage = storage\n    this.state = {}\n\n    // key is intended to act as the k=v pair\n    this.key = key\n\n    this.ee = ee.get(agentIdentifier)\n    wrapEvents(this.ee)\n    this.setup(opts)\n\n    /**\n     * Do not emit session storage events for IE11, because IE11 is unable to determine\n     * if the event was spawned on the current page or an adjacent page, and the behavior tied\n     * to storage events is critical to apply only to cross-tab behavior\n     * */\n    if (isBrowserScope) {\n      windowAddEventListener('storage', (event) => {\n        if (event.key === this.lookupKey) {\n          const obj = typeof event.newValue === 'string' ? JSON.parse(event.newValue) : event.newValue\n          this.sync(obj)\n          this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.CROSS_TAB, this.state])\n        }\n      })\n    }\n  }\n\n  setup ({ value = generateRandomHexString(16), expiresMs = DEFAULT_EXPIRES_MS, inactiveMs = DEFAULT_INACTIVE_MS, numOfResets = 0 }) {\n    /** Ensure that certain properties are preserved across a reset if already set */\n    const persistentAttributes = { serverTimeDiff: this.state.serverTimeDiff || model.serverTimeDiff }\n    this.state = {}\n    this.sync({ ...model, ...persistentAttributes })\n\n    // value is intended to act as the primary value of the k=v pair\n    this.state.value = value\n\n    this.expiresMs = expiresMs\n    this.inactiveMs = inactiveMs\n\n    // the first time the session entity class is instantiated, we check the storage API for an existing\n    // object. If it exists, the values inside the object are used to inform the timers that run locally.\n    // if the initial read is empty, it allows us to set a \"fresh\" \"new\" session immediately.\n    // the local timers are used after the session is running to \"expire\" the session, allowing for pausing timers etc.\n    // the timestamps stored in the storage API can be checked at initial run, and when the page is restored, otherwise we lean\n    // on the local timers to expire the session\n    const initialRead = this.read()\n\n    // the set-up of the timer used to expire the session \"naturally\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    if (expiresMs) {\n      this.state.expiresAt = initialRead?.expiresAt || this.getFutureTimestamp(expiresMs)\n      this.state.numOfResets = initialRead?.numOfResets || numOfResets\n      this.expiresTimer = new Timer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('expired')\n          this.collectSM('duration')\n          this.reset()\n        }\n      }, this.state.expiresAt - Date.now())\n    } else {\n      this.state.expiresAt = Infinity\n    }\n\n    // the set-up of the timer used to expire the session due to \"inactivity\" at a certain time\n    // this gets ignored if the value is falsy, allowing for session entities that do not expire\n    // this gets \"refreshed\" when \"activity\" is observed\n    if (inactiveMs) {\n      this.state.inactiveAt = initialRead?.inactiveAt || this.getFutureTimestamp(inactiveMs)\n      this.inactiveTimer = new InteractionTimer({\n        // When the inactive timer ends, collect a SM and reset the session\n        onEnd: () => {\n          this.collectSM('inactive')\n          this.collectSM('duration')\n          this.reset()\n        },\n        // When the inactive timer refreshes, it will update the storage values with an update timestamp\n        onRefresh: this.refresh.bind(this),\n        onResume: () => { this.ee.emit(SESSION_EVENTS.RESUME) },\n        // When the inactive timer pauses, update the storage values with an update timestamp\n        onPause: () => {\n          if (this.initialized) this.ee.emit(SESSION_EVENTS.PAUSE)\n          this.write(getModeledObject(this.state, model))\n        },\n        ee: this.ee,\n        refreshEvents: ['click', 'keydown', 'scroll'],\n        readStorage: () => this.storage.get(this.lookupKey)\n      }, this.state.inactiveAt - Date.now())\n    } else {\n      this.state.inactiveAt = Infinity\n    }\n\n    // The fact that the session is \"new\" or pre-existing is used in some places in the agent.  Session Replay and Trace\n    // can use this info to inform whether to trust a new sampling decision vs continue a previous tracking effort.\n    /* [NR-230914] 02/2024 - the logical OR assignment is used so that isNew remains 'true' if it was already set as such. This fixes the expires and inactive timestamps timing out in localStorage\n      while no page for a given domain is in-use and the session resetting upon user returning to the page as part of a fresh session. */\n    this.isNew ||= !Object.keys(initialRead).length\n    // if its a \"new\" session, we write to storage API with the default values.  These values may change over the lifespan of the agent run.\n    // we can use a modeled object here to help us know and manage what values are being used. -- see \"model\" above\n    if (this.isNew) this.write(getModeledObject(this.state, model), true)\n    else this.sync(initialRead)\n\n    this.initialized = true\n    this.ee.emit(SESSION_EVENTS.STARTED, [this.isNew])\n  }\n\n  // This is the actual key appended to the storage API\n  get lookupKey () {\n    return `${PREFIX}_${this.key}`\n  }\n\n  sync (data) {\n    Object.assign(this.state, data)\n  }\n\n  /**\n   * Fetch the stored values from the storage API tied to this entity\n   * @returns {Object}\n   */\n  read () {\n    try {\n      const val = this.storage.get(this.lookupKey)\n      if (!val) return {}\n      // TODO - decompression would need to happen here if we decide to do it\n      const obj = typeof val === 'string' ? JSON.parse(val) : val\n      if (this.isInvalid(obj)) return {}\n      // if the session expires, collect a SM count before resetting\n      if (this.isExpired(obj.expiresAt)) {\n        this.collectSM('expired')\n        this.collectSM('duration', obj, true)\n        return this.reset()\n      }\n      // if \"inactive\" timer is expired at \"read\" time -- esp. initial read -- reset\n      // collect a SM count before resetting\n      if (this.isExpired(obj.inactiveAt)) {\n        this.collectSM('inactive')\n        this.collectSM('duration', obj, true)\n        return this.reset()\n      }\n\n      return obj\n    } catch (e) {\n      warn(10, e)\n      // storage is inaccessible\n      return {}\n    }\n  }\n\n  /**\n   * Store data to the storage API tied to this entity\n   * To preseve existing attributes, the output of ...session.read()\n   * should be appended to the data argument\n   * @param {Object} data\n   * @returns {Object}\n   */\n  write (data) {\n    try {\n      if (!data || typeof data !== 'object') return\n      // everytime we update, we can update a timestamp for sanity\n      data.updatedAt = Date.now()\n      this.sync(data) // update the parent class \"state\" properties with the local storage values\n      //\n      // TODO - compression would need happen here if we decide to do it\n      this.storage.set(this.lookupKey, stringify(this.state))\n      this.ee.emit(SESSION_EVENTS.UPDATE, [SESSION_EVENT_TYPES.SAME_TAB, this.state])\n      return data\n    } catch (e) {\n      // storage is inaccessible\n      warn(11, e)\n      return null\n    }\n  }\n\n  reset () {\n    // this method should set off a chain of actions across the features by emitting 'new-session'\n    // * send off pending payloads\n    // * stop recording (stn and sr)...\n    // * delete the session and start over\n    try {\n      if (this.initialized) {\n        this.ee.emit(SESSION_EVENTS.RESET)\n        this.state.numOfResets++\n      }\n      this.storage.remove(this.lookupKey)\n      this.inactiveTimer?.abort?.()\n      this.expiresTimer?.clear?.()\n      delete this.isNew\n\n      this.setup({\n        agentIdentifier: this.agentIdentifier,\n        key: this.key,\n        storage: this.storage,\n        expiresMs: this.expiresMs,\n        inactiveMs: this.inactiveMs,\n        numOfResets: this.state.numOfResets\n      })\n      return this.read()\n    } catch (e) {\n      return {}\n    }\n  }\n\n  /**\n   * Refresh the inactivity timer data\n   */\n  refresh () {\n    // read here & invalidate\n    const existingData = this.read()\n    this.write({ ...existingData, inactiveAt: this.getFutureTimestamp(this.inactiveMs) })\n  }\n\n  /**\n   * @param {number} timestamp\n   * @returns {boolean}\n   */\n  isExpired (timestamp) {\n    return Date.now() > timestamp\n  }\n\n  /**\n   * @param {Object} data\n   * @returns {boolean}\n   */\n  isInvalid (data) {\n    const requiredKeys = Object.keys(model)\n    return !requiredKeys.every(x => Object.keys(data).includes(x))\n  }\n\n  collectSM (type, data, useUpdatedAt) {\n    let value, tag\n    if (type === 'duration') {\n      value = this.getDuration(data, useUpdatedAt)\n      tag = 'Session/Duration/Ms'\n    }\n    if (type === 'expired') tag = 'Session/Expired/Seen'\n    if (type === 'inactive') tag = 'Session/Inactive/Seen'\n\n    if (tag) handle(SUPPORTABILITY_METRIC_CHANNEL, [tag, value], undefined, FEATURE_NAMES.metrics, this.ee)\n  }\n\n  getDuration (data = this.state, useUpdatedAt) {\n    const startingTimestamp = data.expiresAt - this.expiresMs\n    const endingTimestamp = !useUpdatedAt ? data.updatedAt : Date.now()\n    return endingTimestamp - startingTimestamp\n  }\n\n  /**\n   * @param {number} futureMs - The number of ms to use to generate a future timestamp\n   * @returns {number}\n   */\n  getFutureTimestamp (futureMs) {\n    return Date.now() + futureMs\n  }\n\n  syncCustomAttribute (key, value) {\n    if (!isBrowserScope) return\n    if (value === null) {\n      const curr = this.read()\n      if (curr.custom) {\n        delete curr.custom[key]\n        this.write({ ...curr })\n      }\n    } else {\n      const curr = this.read()\n      this.custom = { ...(curr?.custom || {}), [key]: value }\n      this.write({ ...curr, custom: this.custom })\n    }\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class LocalStorage {\n  get (key) {\n    try {\n      // localStorage strangely type-casts non-existing data to \"null\"...\n      // Cast it back to undefined if it doesnt exist\n      return localStorage.getItem(key) || undefined\n    } catch (err) {\n      // Error is ignored\n      return ''\n    }\n  }\n\n  set (key, value) {\n    try {\n      if (value === undefined || value === null) return this.remove(key)\n      return localStorage.setItem(key, value)\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n\n  remove (key) {\n    try {\n      localStorage.removeItem(key)\n    } catch (err) {\n      // Error is ignored\n    }\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { drain } from '../../common/drain/drain'\nimport { ee } from '../../common/event-emitter/contextual-ee'\nimport { registerHandler } from '../../common/event-emitter/register-handler'\nimport { SessionEntity } from '../../common/session/session-entity'\nimport { LocalStorage } from '../../common/storage/local-storage.js'\nimport { DEFAULT_KEY } from '../../common/session/constants'\n\nexport function setupAgentSession (agentRef) {\n  if (agentRef.runtime.session) return agentRef.runtime.session // already setup\n\n  const sessionInit = agentRef.init.session\n\n  agentRef.runtime.session = new SessionEntity({\n    agentIdentifier: agentRef.agentIdentifier,\n    key: DEFAULT_KEY,\n    storage: new LocalStorage(),\n    expiresMs: sessionInit?.expiresMs,\n    inactiveMs: sessionInit?.inactiveMs\n  })\n\n  // Retrieve & re-add all of the persisted setCustomAttribute|setUserId k-v from previous page load(s), if any was stored.\n  const customSessionData = agentRef.runtime.session.state.custom\n  if (customSessionData) {\n    agentRef.info.jsAttributes = { ...agentRef.info.jsAttributes, ...customSessionData }\n  }\n\n  const sharedEE = ee.get(agentRef.agentIdentifier)\n\n  // any calls to newrelic.setCustomAttribute(<persisted>) will need to be added to:\n  // local info.jsAttributes {}\n  // the session's storage API\n  registerHandler('api-setCustomAttribute', (time, key, value) => {\n    agentRef.runtime.session.syncCustomAttribute(key, value)\n  }, 'session', sharedEE)\n\n  // any calls to newrelic.setUserId(...) will need to be added to:\n  // local info.jsAttributes {}\n  // the session's storage API\n  registerHandler('api-setUserId', (time, key, value) => {\n    agentRef.runtime.session.syncCustomAttribute(key, value)\n  }, 'session', sharedEE)\n\n  drain(agentRef.agentIdentifier, 'session')\n\n  return agentRef.runtime.session\n}\n"],"names":["Timer","opts","ms","cb","InteractionTimer","isBrowserScope","debouncedRefresh","debounce","evts","subscribeToVisibilityChange","state","lsData","obj","isExpired","timestamp","model","MODE","LOGGING_MODE","SessionEntity","agentIdentifier","key","storage","ee","wrapEvents","windowAddEventListener","event","SESSION_EVENTS","SESSION_EVENT_TYPES","value","generateRandomHexString","expiresMs","DEFAULT_EXPIRES_MS","inactiveMs","DEFAULT_INACTIVE_MS","numOfResets","persistentAttributes","initialRead","getModeledObject","PREFIX","data","val","warn","stringify","e","existingData","x","type","useUpdatedAt","tag","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","startingTimestamp","futureMs","curr","LocalStorage","setupAgentSession","agentRef","sessionInit","DEFAULT_KEY","customSessionData","sharedEE","registerHandler","time","drain"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}