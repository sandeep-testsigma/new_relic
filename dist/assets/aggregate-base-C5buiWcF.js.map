{"version":3,"file":"aggregate-base-C5buiWcF.js","sources":["../../node_modules/@newrelic/browser-agent/src/common/url/protocol.js","../../node_modules/@newrelic/browser-agent/src/common/util/obfuscate.js","../../node_modules/@newrelic/browser-agent/src/common/constants/agent-constants.js","../../node_modules/@newrelic/browser-agent/src/features/utils/event-store-manager.js","../../node_modules/@newrelic/browser-agent/src/common/unload/eol.js","../../node_modules/@newrelic/browser-agent/src/common/url/clean-url.js","../../node_modules/@newrelic/browser-agent/src/common/url/encode.js","../../node_modules/@newrelic/browser-agent/src/common/util/submit-data.js","../../node_modules/@newrelic/browser-agent/src/common/harvest/harvester.js","../../node_modules/@newrelic/browser-agent/src/features/utils/entity-manager.js","../../node_modules/@newrelic/browser-agent/src/features/utils/event-buffer.js","../../node_modules/@newrelic/browser-agent/src/common/aggregate/aggregator.js","../../node_modules/@newrelic/browser-agent/src/common/aggregate/event-aggregator.js","../../node_modules/@newrelic/browser-agent/src/features/utils/aggregate-base.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope } from '../constants/runtime'\n\nexport function isFileProtocol () {\n  return Boolean(globalScope?.location?.protocol === 'file:')\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { isFileProtocol } from '../url/protocol'\nimport { warn } from './console'\n\n/**\n * Represents an obfuscation rule that can be applied to harvested payloads\n * @typedef {object} ObfuscationRule\n * @property {string|RegExp} regex The regular expression to match against in the payload\n * @property {string} [replacement] The string to replace the matched regex with\n */\n\n/**\n * Represents an obfuscation rule validation state\n * @typedef {object} ObfuscationRuleValidation\n * @property {ObfuscationRule} rule The original rule validated\n * @property {boolean} isValid Whether the rule is valid\n * @property {object} errors Validation errors\n * @property {boolean} errors.regexMissingDetected Whether the regex is missing\n * @property {boolean} errors.invalidRegexDetected Whether the regex is invalid\n * @property {boolean} errors.invalidReplacementDetected Whether the replacement is invalid\n */\n\nexport class Obfuscator {\n  constructor (agentRef) {\n    this.agentRef = agentRef\n    this.warnedRegexMissing = false\n    this.warnedInvalidRegex = false\n    this.warnedInvalidReplacement = false\n  }\n\n  get obfuscateConfigRules () {\n    return this.agentRef.init.obfuscate || []\n  }\n\n  /**\n   * Applies all valid obfuscation rules to the provided input string\n   * @param {string} input String to obfuscate\n   * @returns {string}\n   */\n  obfuscateString (input) {\n    // if input is not of type string or is an empty string, short-circuit\n    if (typeof input !== 'string' || input.trim().length === 0) return input\n\n    const rules = (this.obfuscateConfigRules).map(rule => this.validateObfuscationRule(rule))\n    if (isFileProtocol()) {\n      rules.push({\n        regex: /^file:\\/\\/(.*)/,\n        replacement: atob('ZmlsZTovL09CRlVTQ0FURUQ=')\n      })\n    }\n\n    return rules\n      .filter(ruleValidation => ruleValidation.isValid)\n      .reduce((input, ruleValidation) => {\n        const { rule } = ruleValidation\n        return input.replace(rule.regex, rule.replacement || '*')\n      }, input)\n  }\n\n  /**\n   * Validates an obfuscation rule and provides errors if any are found.\n   * @param {ObfuscationRule} rule The rule to validate\n   * @returns {ObfuscationRuleValidation} The validation state of the rule\n   */\n  validateObfuscationRule (rule) {\n    const regexMissingDetected = Boolean(rule.regex === undefined)\n    const invalidRegexDetected = Boolean(rule.regex !== undefined && typeof rule.regex !== 'string' && !(rule.regex instanceof RegExp))\n    const invalidReplacementDetected = Boolean(rule.replacement && typeof rule.replacement !== 'string')\n\n    if (regexMissingDetected && !this.warnedRegexMissing) {\n      warn(12, rule)\n      this.warnedRegexMissing = true\n    } else if (invalidRegexDetected && !this.warnedInvalidRegex) {\n      warn(13, rule)\n      this.warnedInvalidRegex = true\n    }\n    if (invalidReplacementDetected && !this.warnedInvalidReplacement) {\n      warn(14, rule)\n      this.warnedInvalidReplacement = true\n    }\n\n    return {\n      rule,\n      isValid: !regexMissingDetected && !invalidRegexDetected && !invalidReplacementDetected,\n      errors: {\n        regexMissingDetected,\n        invalidRegexDetected,\n        invalidReplacementDetected\n      }\n    }\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport const IDEAL_PAYLOAD_SIZE = 64000\nexport const MAX_PAYLOAD_SIZE = 1000000\nexport const DEFAULT_KEY = 'NR_CONTAINER_AGENT'\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { DEFAULT_KEY } from '../../common/constants/agent-constants'\nimport { dispatchGlobalEvent } from '../../common/dispatch/global-event'\nimport { activatedFeatures } from '../../common/util/feature-flags'\nimport { isContainerAgentTarget } from '../../common/util/target'\n/**\n * This layer allows multiple browser entity apps, or \"target\", to each have their own segregated storage instance.\n * The purpose is so the harvester can send data to different apps within the same agent. Each feature should have a manager if it needs this capability.\n */\nexport class EventStoreManager {\n  /**\n   * @param {object} agentRef - reference to base agent class\n   * @param {EventBuffer|EventAggregator} storageClass - the type of storage to use in this manager; 'EventBuffer' (1), 'EventAggregator' (2)\n   * @param {string} [defaultEntityGuid] - the entity guid to use as the default storage instance; if not provided, a new one is created\n   * @param {string} featureName - the name of the feature this manager is for; used for event dispatching\n   */\n  constructor (agentRef, storageClass, defaultEntityGuid, featureName) {\n    this.agentRef = agentRef\n    this.entityManager = agentRef.runtime.entityManager\n    this.StorageClass = storageClass\n    this.appStorageMap = new Map([[DEFAULT_KEY, new this.StorageClass()]])\n    this.featureName = featureName\n    this.setEventStore(defaultEntityGuid)\n  }\n\n  /**\n   * Always returns a storage instance.  Creates one if one does not exist.  If a lookup is not provided, uses the DEFAULT namespace\n   * @param {string=} targetEntityGuid the lookup\n   * @returns {*} ALWAYS returns a storage instance\n   */\n  #getEventStore (targetEntityGuid = DEFAULT_KEY) {\n    if (!this.appStorageMap.has(targetEntityGuid)) this.setEventStore(targetEntityGuid)\n    return this.appStorageMap.get(targetEntityGuid)\n  }\n\n  setEventStore (targetEntityGuid) {\n    /** we should already have an event store for the default */\n    if (!targetEntityGuid) return\n    /** if the target is the container agent, SHARE the default storage -- otherwise create a new event store */\n    const eventStorage = (isContainerAgentTarget(this.entityManager.get(targetEntityGuid), this.agentRef))\n      ? this.appStorageMap.get(DEFAULT_KEY)\n      : new this.StorageClass()\n    this.appStorageMap.set(targetEntityGuid, eventStorage)\n  }\n\n  // This class must contain an union of all methods from all supported storage classes and conceptualize away the target app argument.\n\n  /**\n   * Calls the isEmpty method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.\n   * @param {object} optsIfPresent - exists if called during harvest interval, @see AggregateBase.makeHarvestPayload\n   * @param {object} target - specific app's storage to check; if not provided, this method takes into account all apps recorded by this manager\n   * @returns {boolean} True if the target's storage is empty, or target does not exist in map (defaults to all storages)\n   */\n  isEmpty (optsIfPresent, targetEntityGuid) {\n    if (targetEntityGuid) return this.#getEventStore(targetEntityGuid).isEmpty(optsIfPresent)\n\n    for (const eventStore of this.appStorageMap.values()) {\n      if (!eventStore.isEmpty(optsIfPresent)) return false\n    }\n    return true\n  }\n\n  /**\n   * Calls the add method on the underlying storage class.\n   * @param {string} event - the event element to store\n   * @param {object} targetEntityGuid - the entity guid lookup to store event under; if not provided, this method adds to the default\n   * @returns {boolean} True if the event was successfully added\n   */\n  add (event, targetEntityGuid) {\n    dispatchGlobalEvent({\n      agentIdentifier: this.agentRef.agentIdentifier,\n      drained: !!activatedFeatures?.[this.agentRef.agentIdentifier],\n      type: 'data',\n      name: 'buffer',\n      feature: this.featureName,\n      data: event\n    })\n    return this.#getEventStore(targetEntityGuid).add(event)\n  }\n\n  /** This is only used by the Metrics feature which has no need to add metric under a different app atm. */\n  addMetric (type, name, params, value) {\n    return this.#getEventStore().addMetric(type, name, params, value)\n  }\n\n  /**\n   * Calls the get method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.\n   * @param {object=} opts - exists if called during harvest interval, @see AggregateBase.makeHarvestPayload\n   * @param {object=} target - specific app to fetch; if not provided, this method fetches from all apps\n   * @returns {Array} Objects of `data` labeled with their respective `target` app to be sent to\n   */\n  get (opts, targetEntityGuid) {\n    if (targetEntityGuid) return [{ targetApp: this.entityManager.get(targetEntityGuid), data: this.#getEventStore(targetEntityGuid).get(opts) }]\n    const allPayloads = []\n    this.appStorageMap.forEach((eventStore, targetEntityGuid) => {\n      // We shouldnt harvest unless we have a valid entity guid.  It was ONLY stored under the default key temporarily\n      // until a real key was returned in the RUM call. The real key SHARES the event store with the default key, and\n      // should be the key that is honored to get the event store to ensure a valid connection was made.\n      if (targetEntityGuid === DEFAULT_KEY) return\n      const targetApp = this.entityManager.get(targetEntityGuid)\n      if (targetApp) allPayloads.push({ targetApp, data: eventStore.get(opts) })\n    })\n    return allPayloads\n  }\n\n  /**\n   * Calls the byteSize method on the underlying storage class\n   * @param {*} targetEntityGuid\n   * @returns\n   */\n  byteSize (targetEntityGuid) {\n    return this.#getEventStore(targetEntityGuid).byteSize()\n  }\n\n  /**\n   * Calls the wouldExceedMaxSize method on the underlying storage class\n   * @param {*} incomingSize\n   * @param {*} targetEntityGuid\n   * @returns\n   */\n  wouldExceedMaxSize (incomingSize, targetEntityGuid) {\n    return this.#getEventStore(targetEntityGuid).wouldExceedMaxSize(incomingSize)\n  }\n\n  /**\n   * Calls the save method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.\n   * @param {*} optsIfPresent\n   * @param {*} targetEntityGuid\n   * @returns\n   */\n  save (optsIfPresent, targetEntityGuid) {\n    if (targetEntityGuid) return this.#getEventStore(targetEntityGuid).save(optsIfPresent)\n    this.appStorageMap.forEach((eventStore) => eventStore.save(optsIfPresent))\n  }\n\n  /**\n   * Calls the clear method on the underlying storage class. If target is provided, runs just for the target, otherwise runs for all apps.\n   * @param {*} optsIfPresent\n   * @param {*} targetEntityGuid\n   * @returns\n   */\n  clear (optsIfPresent, targetEntityGuid) {\n    if (targetEntityGuid) return this.#getEventStore(targetEntityGuid).clear(optsIfPresent)\n    this.appStorageMap.forEach((eventStore) => eventStore.clear(optsIfPresent))\n  }\n\n  // Unlike the methods above, the following will have a target as they are called by AggregateBase.postHarvestCleanup callback on harvest finish after getting & sending the data.\n  reloadSave (optsIfPresent, targetEntityGuid) {\n    return this.#getEventStore(targetEntityGuid).reloadSave(optsIfPresent)\n  }\n\n  clearSave (optsIfPresent, targetEntityGuid) {\n    return this.#getEventStore(targetEntityGuid).clearSave(optsIfPresent)\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope, isWorkerScope, isBrowserScope } from '../constants/runtime'\nimport { subscribeToVisibilityChange } from '../window/page-visibility'\n\nif (isWorkerScope) {\n  globalScope.cleanupTasks = [] // create new list on WorkerGlobalScope to track funcs to run before exiting thread\n\n  const origClose = globalScope.close\n  globalScope.close = () => { // on worker's EoL signal, execute all \"listeners\", e.g. final harvests\n    for (let task of globalScope.cleanupTasks) {\n      task()\n    }\n    origClose()\n  }\n}\n\n/**\n * Subscribes a provided callback to the time/event when the agent should treat it as end-of-life.\n * This is used, for example, to submit a final harvest and send all remaining data on best-effort.\n * @param {function} cb - func to run before or during the last reliable event or time of an env's life span\n */\nexport function subscribeToEOL (cb, capturePhase) {\n  if (isBrowserScope) {\n    subscribeToVisibilityChange(cb, true, capturePhase) // when user switches tab or hides window, esp. mobile scenario\n  } else if (isWorkerScope) {\n    globalScope.cleanupTasks.push(cb) // close() should run these tasks before quitting thread\n  }\n  // By default (for other env), this fn has no effect.\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar patternWithHash = /([^?#]*)[^#]*(#[^?]*|$).*/\nvar patternWithoutHash = /([^?#]*)().*/\n\n/**\n * Cleans a URL by removing the query string and fragment (hash portion).\n * @param {string} url - The original URL to be cleaned.\n * @param {boolean} [keepHash=false] - Whether to preserve the hash portion of the URL.\n * @returns {string} The cleaned URL.\n */\nexport function cleanURL (url, keepHash) {\n  return url.replace(keepHash ? patternWithHash : patternWithoutHash, '$1$2')\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { stringify } from '../util/stringify'\n\n// Characters that are safe in a qs, but get encoded.\nvar charMap = {\n  '%2C': ',',\n  '%3A': ':',\n  '%2F': '/',\n  '%40': '@',\n  '%24': '$',\n  '%3B': ';'\n}\n\nvar charList = Object.keys(charMap)\nvar safeEncoded = new RegExp(charList.join('|'), 'g')\n\nfunction real (c) {\n  return charMap[c]\n}\n\n// Encode as URI Component, then unescape anything that is ok in the\n// query string position.\nexport function qs (value) {\n  if (value === null || value === undefined) return 'null'\n  return encodeURIComponent(value).replace(safeEncoded, real)\n}\n\nexport function fromArray (qs, maxBytes) {\n  var bytes = 0\n  for (var i = 0; i < qs.length; i++) {\n    bytes += qs[i].length\n    if (bytes > maxBytes) return qs.slice(0, i).join('')\n  }\n  return qs.join('')\n}\n\nexport function obj (payload, maxBytes) {\n  var total = 0\n  var result = ''\n\n  Object.entries(payload || {}).forEach(([feature, dataArray]) => {\n    var intermediate = []\n    var next\n    var i\n\n    if (typeof dataArray === 'string' || (!Array.isArray(dataArray) && dataArray !== null && dataArray !== undefined && dataArray.toString().length)) {\n      next = '&' + feature + '=' + qs(dataArray)\n      total += next.length\n      result += next\n    } else if (Array.isArray(dataArray) && dataArray.length) {\n      total += 9\n      for (i = 0; i < dataArray.length; i++) {\n        next = qs(stringify(dataArray[i]))\n        total += next.length\n        if (typeof maxBytes !== 'undefined' && total >= maxBytes) break\n        intermediate.push(next)\n      }\n      result += '&' + feature + '=%5B' + intermediate.join(',') + '%5D'\n    }\n  })\n  return result\n}\n\n// Constructs an HTTP parameter to add to the BAM router URL\nexport function param (name, value, base = {}) {\n  if (Object.keys(base).includes(name)) return '' // we assume if feature supplied a matching qp to the base, we should honor what the feature sent over the default\n  if (value && typeof (value) === 'string') {\n    return '&' + name + '=' + qs(value)\n  }\n  return ''\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Contains common methods used to transmit harvested data.\n * @copyright 2023 New Relic Corporation. All rights reserved.\n * @license Apache-2.0\n */\n\nimport { isBrowserScope } from '../constants/runtime'\n\n/**\n * @typedef {xhr|beacon} NetworkMethods\n */\n\n/**\n * Determines the submit method to use based on options.\n * @param {object} opts Options used to determine submit method.\n * @param {boolean} opts.isFinalHarvest Indicates if the data submission is due to\n * a final harvest within the agent.\n */\nexport function getSubmitMethod ({ isFinalHarvest = false } = {}) {\n  if (isFinalHarvest && isBrowserScope) {\n    // Use sendBeacon for final harvest\n    return beacon\n  }\n\n  // If not final harvest, or not browserScope, use XHR post if available\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return xhr\n  }\n\n  // Fallback for web workers where XMLHttpRequest is not available\n  return xhrFetch\n}\n\n/**\n *\n * @param url\n * @param body\n * @param method\n * @param headers\n * @returns {Promise<Response>}\n */\nexport function xhrFetch ({\n  url,\n  body = null,\n  method = 'POST',\n  headers = [{\n    key: 'content-type',\n    value: 'text/plain'\n  }]\n}) {\n  const objHeaders = {}\n\n  for (const header of headers) {\n    objHeaders[header.key] = header.value\n  }\n\n  return fetch(url, { headers: objHeaders, method, body, credentials: 'include' })\n}\n\n/**\n * Send via XHR\n * @param {Object} args - The args.\n * @param {string} args.url - The URL to send to.\n * @param {string=} args.body - The Stringified body. Default null to prevent IE11 from breaking.\n * @param {boolean=} args.sync - Run XHR synchronously.\n * @param {string=} [args.method=POST] - The XHR method to use.\n * @param {{key: string, value: string}[]} [args.headers] - The headers to attach.\n * @returns {XMLHttpRequest}\n */\nexport function xhr ({ url, body = null, sync, method = 'POST', headers = [{ key: 'content-type', value: 'text/plain' }] }) {\n  const request = new XMLHttpRequest()\n\n  request.open(method, url, !sync)\n  try {\n    // Set cookie\n    if ('withCredentials' in request) request.withCredentials = true\n  } catch (e) {\n    // do nothing\n  }\n\n  headers.forEach(header => {\n    request.setRequestHeader(header.key, header.value)\n  })\n\n  request.send(body)\n  return request\n}\n\n/**\n * Send via sendBeacon. Do NOT call this function outside of a guaranteed web window environment.\n * @param {Object} args - The args\n * @param {string} args.url - The URL to send to\n * @param {string=} args.body - The Stringified body\n * @returns {boolean}\n */\nexport function beacon ({ url, body }) {\n  try {\n    // Navigator has to be bound to ensure it does not error in some browsers\n    // https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    const send = window.navigator.sendBeacon.bind(window.navigator)\n    return send(url, body)\n  } catch (err) {\n    // if sendBeacon still trys to throw an illegal invocation error,\n    // we can catch here and return\n    return false\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../features/metrics/constants'\nimport { FEATURE_TO_ENDPOINT, JSERRORS, RUM, EVENTS, FEATURE_NAMES, BLOBS, LOGS } from '../../loaders/features/features'\nimport { VERSION } from '../constants/env'\nimport { globalScope, isWorkerScope } from '../constants/runtime'\nimport { handle } from '../event-emitter/handle'\nimport { eventListenerOpts } from '../event-listener/event-listener-opts'\nimport { now } from '../timing/now'\nimport { subscribeToEOL } from '../unload/eol'\nimport { cleanURL } from '../url/clean-url'\nimport { obj, param } from '../url/encode'\nimport { warn } from '../util/console'\nimport { stringify } from '../util/stringify'\nimport { getSubmitMethod, xhr as xhrMethod, xhrFetch as fetchMethod } from '../util/submit-data'\nimport { activatedFeatures } from '../util/feature-flags'\nimport { dispatchGlobalEvent } from '../dispatch/global-event'\n\nconst RETRY_FAILED = 'Harvester/Retry/Failed/'\nconst RETRY_SUCCEEDED = 'Harvester/Retry/Succeeded/'\n\nexport class Harvester {\n  #started = false\n  initializedAggregates = []\n\n  constructor (agentRef) {\n    this.agentRef = agentRef\n\n    subscribeToEOL(() => { // do one last harvest round or check\n      this.initializedAggregates.forEach(aggregateInst => { // let all features wrap up things needed to do before ANY harvest in case there's last minute cross-feature data dependencies\n        if (typeof aggregateInst.harvestOpts.beforeUnload === 'function') aggregateInst.harvestOpts.beforeUnload()\n      })\n      this.initializedAggregates.forEach(aggregateInst => this.triggerHarvestFor(aggregateInst, { isFinalHarvest: true }))\n      /* This callback should run in bubble phase, so that that CWV api, like \"onLCP\", is called before the final harvest so that emitted timings are part of last outgoing. */\n    }, false)\n  }\n\n  startTimer (harvestInterval = this.agentRef.init.harvest.interval) {\n    if (this.#started) return\n    this.#started = true\n\n    const onHarvestInterval = () => {\n      this.initializedAggregates.forEach(aggregateInst => this.triggerHarvestFor(aggregateInst))\n      setTimeout(onHarvestInterval, harvestInterval * 1000) // repeat in X seconds\n    }\n    setTimeout(onHarvestInterval, harvestInterval * 1000)\n  }\n\n  /**\n   * Given a feature (aggregate), execute a harvest on-demand.\n   * @param {object} aggregateInst\n   * @param {object} localOpts\n   * @returns {boolean} True if 1+ network call was made. Note that this does not mean or guarantee that it was successful (or that all were in the case of more than 1).\n   */\n  triggerHarvestFor (aggregateInst, localOpts = {}) {\n    if (aggregateInst.blocked) return false\n\n    const submitMethod = getSubmitMethod(localOpts)\n    if (!submitMethod) return false\n\n    const shouldRetryOnFail = !localOpts.isFinalHarvest && submitMethod === xhrMethod // always retry all features harvests except for final\n    let dataToSendArr; let ranSend = false\n    if (!localOpts.directSend) { // primarily used by rum call to bypass makeHarvestPayload by providing payload directly\n      dataToSendArr = aggregateInst.makeHarvestPayload(shouldRetryOnFail, localOpts) // be sure the 'this' of makeHarvestPayload is the aggregate w/ access to its harvestOpts\n      if (!dataToSendArr) return false // can be undefined if storage is empty or preharvest checks failed\n    } else dataToSendArr = [localOpts.directSend]\n\n    dataToSendArr.forEach(({ targetApp, payload }) => {\n      if (!payload) return\n\n      send(this.agentRef, {\n        endpoint: FEATURE_TO_ENDPOINT[aggregateInst.featureName],\n        targetApp,\n        payload,\n        localOpts,\n        submitMethod,\n        cbFinished,\n        raw: aggregateInst.harvestOpts.raw,\n        featureName: aggregateInst.featureName\n      })\n      ranSend = true\n    })\n    return ranSend\n\n    /**\n     * This is executed immediately after harvest sends the data via XHR, or if there's nothing to send. Note that this excludes on unloading / sendBeacon.\n     * @param {Object} result - information regarding the result of the harvest attempt\n     */\n    function cbFinished (result) {\n      if (aggregateInst.harvestOpts.prevAttemptCode) { // this means we just retried a harvest that last failed\n        handle(SUPPORTABILITY_METRIC_CHANNEL, [(result.retry ? RETRY_FAILED : RETRY_SUCCEEDED) + aggregateInst.harvestOpts.prevAttemptCode], undefined, FEATURE_NAMES.metrics, aggregateInst.ee)\n        delete aggregateInst.harvestOpts.prevAttemptCode // always reset last observation so we don't falsely report again next harvest\n        // In case this re-attempt failed again, that'll be handled (re-marked again) next.\n      }\n      if (result.retry) aggregateInst.harvestOpts.prevAttemptCode = result.status // earmark this Agg harvest as failed-but-retrying for next harvest trigger so we can capture metrics about retries\n\n      if (localOpts.forceNoRetry) result.retry = false // discard unsent data rather than re-queuing for next harvest attempt; used by session reset to flush data belonging to prev session\n      aggregateInst.postHarvestCleanup(result)\n    }\n  }\n}\n\n/**\n * @typedef {import('./types.js').NetworkSendSpec} NetworkSendSpec\n */\n\nconst warnings = {}\n/**\n  * Initiate a harvest call.\n  * @param {NetworkSendSpec} param0 Specification for sending data\n  * @returns {boolean} True if a network call was made. Note that this does not mean or guarantee that it was successful.\n  */\nfunction send (agentRef, { endpoint, targetApp, payload, localOpts = {}, submitMethod, cbFinished, raw, featureName }) {\n  if (!agentRef.info.errorBeacon) return false\n\n  let { body, qs } = cleanPayload(payload)\n\n  if (Object.keys(body).length === 0 && !localOpts.sendEmptyBody) { // if there's no body to send, just run onfinish stuff and return\n    if (cbFinished) cbFinished({ sent: false, targetApp })\n    return false\n  }\n\n  const protocol = agentRef.init.ssl === false ? 'http' : 'https'\n  const perceivedBeacon = agentRef.init.proxy.beacon || agentRef.info.errorBeacon\n  const url = raw\n    ? `${protocol}://${perceivedBeacon}/${endpoint}`\n    : `${protocol}://${perceivedBeacon}${endpoint !== RUM ? '/' + endpoint : ''}/1/${targetApp.licenseKey}`\n  const baseParams = !raw ? baseQueryString(agentRef, qs, endpoint, targetApp.applicationID) : ''\n  let payloadParams = obj(qs, agentRef.runtime.maxBytes)\n  if (baseParams === '' && payloadParams.startsWith('&')) {\n    payloadParams = payloadParams.substring(1)\n  }\n\n  const fullUrl = `${url}?${baseParams}${payloadParams}`\n  const gzip = !!qs?.attributes?.includes('gzip')\n  if (!gzip) {\n    if (endpoint !== EVENTS) body = stringify(body) // all features going to 'events' endpoint should already be serialized & stringified\n    // Warn--once per endpoint--if the agent tries to send large payloads\n    if (body.length > 750000 && (warnings[endpoint] = (warnings[endpoint] || 0) + 1) === 1) warn(28, endpoint)\n  }\n\n  // If body is null, undefined, or an empty object or array after stringifying, send an empty string instead.\n  if (!body || body.length === 0 || body === '{}' || body === '[]') body = ''\n\n  const headers = [{ key: 'content-type', value: 'text/plain' }]\n\n  /* Since workers don't support sendBeacon right now, they can only use XHR method.\n      Because they still do permit synch XHR, the idea is that at final harvest time (worker is closing),\n      we just make a BLOCKING request--trivial impact--with the remaining data as a temp fill-in for sendBeacon.\n     Following the removal of img-element method. */\n  let result = submitMethod({ url: fullUrl, body, sync: localOpts.isFinalHarvest && isWorkerScope, headers })\n\n  if (!localOpts.isFinalHarvest && cbFinished) { // final harvests don't hold onto buffer data (shouldRetryOnFail is false), so cleanup isn't needed\n    if (submitMethod === xhrMethod) {\n      result.addEventListener('loadend', function () {\n        // `this` here in block refers to the XHR object in this scope, do not change the anon function to an arrow function\n        // status 0 refers to a local error, such as CORS or network failure, or a blocked request by the browser (e.g. adblocker)\n        const cbResult = { sent: this.status !== 0, status: this.status, retry: shouldRetry(this.status), fullUrl, xhr: this, targetApp }\n        if (localOpts.needResponse) cbResult.responseText = this.responseText\n        cbFinished(cbResult)\n      }, eventListenerOpts(false))\n    } else if (submitMethod === fetchMethod) {\n      result.then(async function (response) {\n        const status = response.status\n        const cbResult = { sent: true, status, retry: shouldRetry(status), fullUrl, fetchResponse: response, targetApp }\n        if (localOpts.needResponse) cbResult.responseText = await response.text()\n        cbFinished(cbResult)\n      })\n    }\n  }\n\n  dispatchGlobalEvent({\n    agentIdentifier: agentRef.agentIdentifier,\n    drained: !!activatedFeatures?.[agentRef.agentIdentifier],\n    type: 'data',\n    name: 'harvest',\n    feature: featureName,\n    data: {\n      endpoint,\n      headers,\n      targetApp,\n      payload,\n      submitMethod: getSubmitMethodName(),\n      raw,\n      synchronousXhr: !!(localOpts.isFinalHarvest && isWorkerScope)\n    }\n  })\n\n  return true\n\n  function shouldRetry (status) {\n    switch (status) {\n      case 408:\n      case 429:\n      case 500:\n        return true\n    }\n    return (status >= 502 && status <= 504) || (status >= 512 && status <= 530)\n  }\n\n  function getSubmitMethodName () {\n    if (submitMethod === xhrMethod) return 'xhr'\n    if (submitMethod === fetchMethod) return 'fetch'\n    return 'beacon'\n  }\n}\n\n/**\n * Cleans and returns a payload object containing a body and qs\n * object with key/value pairs. KV pairs where the value is null,\n * undefined, or an empty string are removed to save on transmission\n * size.\n * @param {HarvestPayload} payload Payload to be sent to the endpoint.\n * @returns {HarvestPayload} Cleaned payload payload to be sent to the endpoint.\n */\nfunction cleanPayload (payload = {}) {\n  const clean = (input) => {\n    if ((typeof Uint8Array !== 'undefined' && input instanceof Uint8Array) || Array.isArray(input)) return input\n    if (typeof input === 'string') return input.length > 0 ? input : null\n    return Object.entries(input || {}).reduce((accumulator, [key, value]) => {\n      if ((typeof value === 'number') ||\n          (typeof value === 'string' && value.length > 0) ||\n          (typeof value === 'object' && Object.keys(value || {}).length > 0)\n      ) {\n        accumulator[key] = value\n      }\n      return accumulator\n    }, {})\n  }\n\n  return {\n    body: clean(payload.body),\n    qs: clean(payload.qs)\n  }\n}\n\n// The stuff that gets sent every time.\nfunction baseQueryString (agentRef, qs, endpoint, applicationID) {\n  const ref = agentRef.runtime.obfuscator.obfuscateString(cleanURL('' + globalScope.location))\n  const hr = agentRef.runtime.session?.state.sessionReplayMode === 1 && endpoint !== JSERRORS\n  const ht = agentRef.runtime.session?.state.sessionTraceMode === 1 && ![LOGS, BLOBS].includes(endpoint)\n\n  const qps = [\n    'a=' + applicationID,\n    param('sa', (agentRef.info.sa ? '' + agentRef.info.sa : '')),\n    param('v', VERSION),\n    transactionNameParam(),\n    param('ct', agentRef.runtime.customTransaction),\n    '&rst=' + now(),\n    '&ck=0', // ck param DEPRECATED - still expected by backend\n    '&s=' + (agentRef.runtime.session?.state.value || '0'), // the 0 id encaps all untrackable and default traffic\n    param('ref', ref),\n    param('ptid', (agentRef.runtime.ptid ? '' + agentRef.runtime.ptid : ''))\n  ]\n  if (hr) qps.push(param('hr', '1', qs))\n  if (ht) qps.push(param('ht', '1', qs))\n\n  return qps.join('')\n\n  // Constructs the transaction name param for the beacon URL.\n  // Prefers the obfuscated transaction name over the plain text.\n  // Falls back to making up a name.\n  function transactionNameParam () {\n    if (agentRef.info.transactionName) return param('to', agentRef.info.transactionName)\n    return param('t', agentRef.info.tNamePlain || 'Unnamed Transaction')\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DEFAULT_KEY } from '../../common/constants/agent-constants'\n\nexport class EntityManager {\n  #entities = new Map()\n  #entityGuidLookup = {}\n\n  constructor (agentRef) {\n    this.agentRef = agentRef\n    this.#entities.set(DEFAULT_KEY, { licenseKey: agentRef.info.licenseKey, applicationID: agentRef.info.applicationID })\n  }\n\n  get (entityGuid = DEFAULT_KEY) {\n    return this.#entities.get(entityGuid)\n  }\n\n  getEntityGuidFor (licenseKey, applicationID) {\n    if (!this.#entityGuidLookup[licenseKey] || !this.#entityGuidLookup[applicationID]) return\n    return this.#entityGuidLookup[licenseKey].filter(x => this.#entityGuidLookup[applicationID].includes(x))[0]\n  }\n\n  set (entityGuid, entity) {\n    if (this.#entities.has(entityGuid)) return\n    this.#entities.set(entityGuid, entity)\n\n    this.#entityGuidLookup[entity.licenseKey] ??= []\n    this.#entityGuidLookup[entity.licenseKey].push(entityGuid)\n    this.#entityGuidLookup[entity.applicationID] ??= []\n    this.#entityGuidLookup[entity.applicationID].push(entityGuid)\n\n    this.agentRef.ee.emit('entity-added', [entity])\n  }\n\n  clear () {\n    this.#entities.clear()\n  }\n\n  setDefaultEntity (entity) {\n    this.#entities.set(DEFAULT_KEY, entity)\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { stringify } from '../../common/util/stringify'\nimport { MAX_PAYLOAD_SIZE } from '../../common/constants/agent-constants'\n\nexport class EventBuffer {\n  #buffer = []\n  #rawBytes = 0\n  #bufferBackup\n  #rawBytesBackup\n\n  /**\n   * @param {number} maxPayloadSize\n   */\n  constructor (maxPayloadSize = MAX_PAYLOAD_SIZE) {\n    this.maxPayloadSize = maxPayloadSize\n  }\n\n  isEmpty () {\n    return this.#buffer.length === 0\n  }\n\n  get () {\n    return this.#buffer\n  }\n\n  byteSize () {\n    return this.#rawBytes\n  }\n\n  wouldExceedMaxSize (incomingSize) {\n    return this.#rawBytes + incomingSize > this.maxPayloadSize\n  }\n\n  /**\n   * Add feature-processed event to our buffer. If this event would cause our total raw size to exceed the set max payload size, it is dropped.\n   * @param {any} event - any primitive type or object\n   * @returns {Boolean} true if successfully added; false otherwise\n   */\n  add (event) {\n    const addSize = stringify(event)?.length || 0 // (estimate) # of bytes a directly stringified event it would take to send\n    if (this.#rawBytes + addSize > this.maxPayloadSize) return false\n    this.#buffer.push(event)\n    this.#rawBytes += addSize\n    return true\n  }\n\n  /**\n   * Wipes the main buffer\n   */\n  clear () {\n    this.#buffer = []\n    this.#rawBytes = 0\n  }\n\n  /**\n   * Backup the buffered data and clear the main buffer\n   */\n  save () {\n    this.#bufferBackup = this.#buffer\n    this.#rawBytesBackup = this.#rawBytes\n  }\n\n  /**\n   * Wipes the backup buffer\n   */\n  clearSave () {\n    this.#bufferBackup = undefined\n    this.#rawBytesBackup = undefined\n  }\n\n  /**\n   * Prepend the backup buffer back into the main buffer\n   */\n  reloadSave () {\n    if (!this.#bufferBackup) return\n    if (this.#rawBytesBackup + this.#rawBytes > this.maxPayloadSize) return\n    this.#buffer = [...this.#bufferBackup, ...this.#buffer]\n    this.#rawBytes = this.#rawBytesBackup + this.#rawBytes\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nexport class Aggregator {\n  constructor () {\n    this.aggregatedData = {}\n  }\n\n  // Items with the same type and name get aggregated together\n  // params are example data from the aggregated items\n  // metrics are the numeric values to be aggregated\n\n  store (type, name, params, newMetrics, customParams) {\n    var bucket = this.#getBucket(type, name, params, customParams)\n    bucket.metrics = aggregateMetrics(newMetrics, bucket.metrics)\n    return bucket\n  }\n\n  merge (type, name, metrics, params, customParams, overwriteParams = false) {\n    var bucket = this.#getBucket(type, name, params, customParams)\n    if (overwriteParams) bucket.params = params // replace current params with incoming params obj\n\n    if (!bucket.metrics) {\n      bucket.metrics = metrics\n      return\n    }\n\n    var oldMetrics = bucket.metrics\n    oldMetrics.count += metrics.count\n\n    // iterate through each new metric and merge\n    Object.keys(metrics || {}).forEach((key) => {\n      // count is a special case handled above\n      if (key === 'count') return\n\n      var oldMetric = oldMetrics[key]\n      var newMetric = metrics[key]\n\n      // handling the case where newMetric is a single-value first\n      if (newMetric && !newMetric.c) {\n        oldMetrics[key] = updateMetric(newMetric.t, oldMetric)\n      } else { // newMetric is a metric object\n        oldMetrics[key] = mergeMetric(newMetric, oldMetrics[key])\n      }\n    })\n  }\n\n  storeMetric (type, name, params, value) {\n    var bucket = this.#getBucket(type, name, params)\n    bucket.stats = updateMetric(value, bucket.stats)\n    return bucket\n  }\n\n  // Get all listed types buckets and it deletes the retrieved content from the aggregatedData\n  take (types, deleteWhenRetrieved = true) {\n    var results = {}\n    var type = ''\n    var hasData = false\n    for (var i = 0; i < types.length; i++) {\n      type = types[i]\n      results[type] = Object.values(this.aggregatedData[type] || {})\n\n      if (results[type].length) hasData = true\n      if (deleteWhenRetrieved) delete this.aggregatedData[type]\n    }\n    return hasData ? results : null\n  }\n\n  #getBucket (type, name, params, customParams) {\n    if (!this.aggregatedData[type]) this.aggregatedData[type] = {}\n    var bucket = this.aggregatedData[type][name]\n    if (!bucket) {\n      bucket = this.aggregatedData[type][name] = { params: params || {} }\n      if (customParams) {\n        bucket.custom = customParams\n      }\n    }\n    return bucket\n  }\n}\n\nfunction aggregateMetrics (newMetrics, oldMetrics) {\n  if (!oldMetrics) oldMetrics = { count: 0 }\n  oldMetrics.count += 1\n  Object.entries(newMetrics || {}).forEach(([key, value]) => {\n    oldMetrics[key] = updateMetric(value, oldMetrics[key])\n  })\n  return oldMetrics\n}\n\nfunction updateMetric (value, metric) {\n  // when there is no value, then send only count\n  if (value == null) {\n    return updateCounterMetric(metric)\n  }\n\n  // When there is only one data point, the c (count), min, max, and sos (sum of squares) params are superfluous.\n  if (!metric) return { t: value }\n\n  // but on the second data point, we need to calculate the other values before aggregating in new values\n  if (!metric.c) {\n    metric = createMetricObject(metric.t)\n  }\n\n  // at this point, metric is always uncondensed\n  metric.c += 1\n  metric.t += value\n  metric.sos += value * value\n  if (value > metric.max) metric.max = value\n  if (value < metric.min) metric.min = value\n\n  return metric\n}\n\nfunction updateCounterMetric (metric) {\n  if (!metric) {\n    metric = { c: 1 }\n  } else {\n    metric.c++\n  }\n  return metric\n}\n\nfunction mergeMetric (newMetric, oldMetric) {\n  if (!oldMetric) return newMetric\n\n  if (!oldMetric.c) {\n    // oldMetric is a single-value\n    oldMetric = createMetricObject(oldMetric.t)\n  }\n\n  oldMetric.min = Math.min(newMetric.min, oldMetric.min)\n  oldMetric.max = Math.max(newMetric.max, oldMetric.max)\n  oldMetric.t += newMetric.t\n  oldMetric.sos += newMetric.sos\n  oldMetric.c += newMetric.c\n\n  return oldMetric\n}\n\n// take a value and create a metric object\nfunction createMetricObject (value) {\n  return {\n    t: value,\n    min: value,\n    max: value,\n    sos: value * value,\n    c: 1\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Aggregator } from './aggregator'\n\n/**\n * An extension of the Aggregator class that provides an interface similar to that of EventBuffer class.\n * This typecasting allow features that uses Aggregator as their event handler to share the same AggregateBase.events utilization by those features.\n */\nexport class EventAggregator {\n  #aggregator = new Aggregator()\n  #savedNamesToBuckets = {}\n\n  isEmpty ({ aggregatorTypes }) {\n    if (!aggregatorTypes) return Object.keys(this.#aggregator.aggregatedData).length === 0\n    return aggregatorTypes.every(type => !this.#aggregator.aggregatedData[type]) // no bucket exist for any of the types we're looking for\n  }\n\n  add ([type, name, params, newMetrics, customParams]) {\n    // Do we need to track byte size here like EventBuffer?\n    this.#aggregator.store(type, name, params, newMetrics, customParams)\n    return true\n  }\n\n  addMetric (type, name, params, value) {\n    this.#aggregator.storeMetric(type, name, params, value)\n    return true\n  }\n\n  save ({ aggregatorTypes }) {\n    const key = aggregatorTypes.toString() // the stringified types serve as the key to each save call, e.g. ['err', 'ierr', 'xhr'] => 'err,ierr,xhr'\n    const backupAggregatedDataSubset = {}\n    aggregatorTypes.forEach(type => (backupAggregatedDataSubset[type] = this.#aggregator.aggregatedData[type])) // make a subset of the aggregatedData for each of the types we want to save\n    this.#savedNamesToBuckets[key] = backupAggregatedDataSubset\n    /*\n    { 'err,ierr,xhr': {\n        'err': {\n            <aggregateHash>: { metrics: { count: 1, time, ... }, params: {}, custom: {} },\n            <otherHashName>: { metrics: { count: 1, ... }, ... }\n        },\n        'ierr': { ... },\n        'xhr': { ... }\n      }\n    }\n    */\n  }\n\n  get (opts) {\n    const aggregatorTypes = Array.isArray(opts) ? opts : opts.aggregatorTypes\n    return this.#aggregator.take(aggregatorTypes, false)\n  }\n\n  clear ({ aggregatorTypes } = {}) {\n    if (!aggregatorTypes) {\n      this.#aggregator.aggregatedData = {}\n      return\n    }\n    aggregatorTypes.forEach(type => delete this.#aggregator.aggregatedData[type])\n  }\n\n  reloadSave ({ aggregatorTypes }) {\n    const key = aggregatorTypes.toString()\n    const backupAggregatedDataSubset = this.#savedNamesToBuckets[key]\n    // Grabs the previously stored subset and merge it back into aggregatedData.\n    aggregatorTypes.forEach(type => {\n      Object.keys(backupAggregatedDataSubset[type] || {}).forEach(name => {\n        const bucket = backupAggregatedDataSubset[type][name]\n        // The older aka saved params take effect over the newer one. This is especially important when merging back for a failed harvest retry if, for example,\n        // the first-ever occurrence of an error is in the retry: it contains the params.stack_trace whereas the newer or current bucket.params would not.\n        this.#aggregator.merge(type, name, bucket.metrics, bucket.params, bucket.custom, true)\n      })\n    })\n  }\n\n  clearSave ({ aggregatorTypes }) {\n    const key = aggregatorTypes.toString()\n    delete this.#savedNamesToBuckets[key]\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { FeatureBase } from './feature-base'\nimport { isValid } from '../../common/config/info'\nimport { configure } from '../../loaders/configure/configure'\nimport { gosCDN } from '../../common/window/nreum'\nimport { drain } from '../../common/drain/drain'\nimport { activatedFeatures } from '../../common/util/feature-flags'\nimport { Obfuscator } from '../../common/util/obfuscate'\nimport { FEATURE_NAMES } from '../../loaders/features/features'\nimport { EventStoreManager } from './event-store-manager'\nimport { Harvester } from '../../common/harvest/harvester'\nimport { warn } from '../../common/util/console'\nimport { EntityManager } from './entity-manager'\nimport { EventBuffer } from './event-buffer'\nimport { handle } from '../../common/event-emitter/handle'\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../metrics/constants'\nimport { EventAggregator } from '../../common/aggregate/event-aggregator'\n\nexport class AggregateBase extends FeatureBase {\n  /**\n   * Create an AggregateBase instance.\n   * @param {Object} agentRef The reference to the agent instance.\n   * @param {string} featureName The name of the feature creating the instance.\n   */\n  constructor (agentRef, featureName) {\n    super(agentRef.agentIdentifier, featureName)\n    this.agentRef = agentRef\n    this.checkConfiguration(agentRef)\n    this.doOnceForAllAggregate(agentRef)\n\n    this.harvestOpts = {} // features aggregate classes can define custom opts for when their harvest is called\n\n    const agentEntityGuid = this.agentRef?.runtime?.appMetadata?.agents?.[0]?.entityGuid\n    this.#setupEventStore(agentEntityGuid)\n    if (!agentEntityGuid) {\n      /** wait for the entity guid from the rum response and use to it to further configure things to set the default entity to share an indexed entity with entityGuid */\n      this.ee.on('entity-added', entity => {\n        // not all event managers have this fn, like ST and SR\n        // this allows the lookup to work for the default and an entityGuid without creating two separate buffers\n        this.events?.setEventStore?.(entity.entityGuid)\n      })\n    }\n  }\n\n  /**\n   * sets up the event store for the feature.  It must wait for the entity guid to be available before setting up the event store.  This is called once the rum response is received with an entityGuid.\n   * @param {string} entityGuid\n   * @returns {void}\n   */\n  #setupEventStore (entityGuid) {\n    if (this.events) return\n    switch (this.featureName) {\n    // SessionTrace + Replay have their own storage mechanisms.\n      case FEATURE_NAMES.sessionTrace:\n      case FEATURE_NAMES.sessionReplay:\n        break\n        // Jserror and Metric features uses a singleton EventAggregator instead of a regular EventBuffer.\n      case FEATURE_NAMES.jserrors:\n      case FEATURE_NAMES.metrics:\n        this.events = this.agentRef.sharedAggregator ??= new EventStoreManager(this.agentRef, EventAggregator, entityGuid, 'shared_aggregator')\n        break\n        /** All other features get EventBuffer in the ESM by default. Note: PVE is included here, but event buffer will always be empty so future harvests will still not happen by interval or EOL.\n    This was necessary to prevent race cond. issues where the event buffer was checked before the feature could \"block\" itself.\n    Its easier to just keep an empty event buffer in place. */\n      default:\n        this.events = new EventStoreManager(this.agentRef, EventBuffer, entityGuid, this.featureName)\n        break\n    }\n  }\n\n  /**\n   * New handler for waiting for multiple flags. Useful when expecting multiple flags simultaneously (ex. stn vs sr)\n   * @param {string[]} flagNames\n   * @returns {Promise}\n   */\n  waitForFlags (flagNames = []) {\n    const flagsPromise = new Promise((resolve, reject) => {\n      if (activatedFeatures[this.agentIdentifier]) {\n        resolve(buildOutput(activatedFeatures[this.agentIdentifier]))\n      } else {\n        this.ee.on('rumresp', (resp = {}) => {\n          resolve(buildOutput(resp))\n        })\n      }\n      function buildOutput (ref) {\n        return flagNames.map(flag => {\n          if (!ref[flag]) return 0\n          return ref[flag]\n        })\n      }\n    })\n    return flagsPromise.catch(err => {\n      this.ee.emit('internal-error', [err])\n      this.blocked = true\n      this.deregisterDrain()\n    })\n  }\n\n  /**\n   * Stages the feature to be drained\n   */\n  drain () {\n    drain(this.agentIdentifier, this.featureName)\n    this.drained = true\n  }\n\n  preHarvestChecks (opts) {\n    return !this.blocked\n  }\n\n  /**\n   * Return harvest payload. A \"serializer\" function can be defined on a derived class to format the payload.\n   * @param {Boolean} shouldRetryOnFail - harvester flag to backup payload for retry later if harvest request fails; this should be moved to harvester logic\n   * @param {object|undefined} opts - opts passed from the harvester to help form the payload\n   * @param {string} opts.targetEntityGuid - the entity guid of the target app\n   * @returns {Array} Final payload tagged with their targeting browser app. The value of `payload` can be undefined if there are no pending events for an app. This should be a minimum length of 1.\n   */\n  makeHarvestPayload (shouldRetryOnFail = false, opts = {}) {\n    if (!this.events || this.events.isEmpty(this.harvestOpts, opts.targetEntityGuid)) return\n    // Other conditions and things to do when preparing harvest that is required.\n    if (this.preHarvestChecks && !this.preHarvestChecks(opts)) return\n\n    if (shouldRetryOnFail) this.events.save(this.harvestOpts, opts.targetEntityGuid)\n    const returnedDataArr = this.events.get(this.harvestOpts, opts.targetEntityGuid)\n    if (!returnedDataArr.length) return warn(52)\n    this.events.clear(this.harvestOpts, opts.targetEntityGuid)\n\n    return returnedDataArr.map(({ targetApp, data }) => {\n      // A serializer or formatter assists in creating the payload `body` from stored events on harvest when defined by derived feature class.\n      const body = this.serializer ? this.serializer(data, targetApp?.entityGuid) : data\n      const payload = {\n        body\n      }\n      // Constructs the payload `qs` for relevant features on harvest.\n      if (this.queryStringsBuilder) payload.qs = this.queryStringsBuilder(data, targetApp?.entityGuid)\n\n      return { targetApp, payload }\n    })\n  }\n\n  /**\n   * Cleanup task after a harvest.\n   * @param {object} result - the cbResult object from the harvester's send method\n   * @param {object=} result.targetApp - the target app object that was used to point the harvest to the correct app\n   * @param {string=} result.targetApp.entityGuid - the entity guid of the target app\n   * @param {boolean=} result.sent - whether the harvest was sent successfully\n   * @param {boolean=} result.retry - whether the harvest should be retried\n   */\n  postHarvestCleanup (result = {}) {\n    const harvestFailed = result.sent && result.retry\n    if (harvestFailed) this.events.reloadSave(this.harvestOpts, result.targetApp?.entityGuid)\n    this.events.clearSave(this.harvestOpts, result.targetApp?.entityGuid)\n  }\n\n  /**\n   * Checks for additional `jsAttributes` items to support backward compatibility with implementations of the agent where\n   * loader configurations may appear after the loader code is executed.\n   */\n  checkConfiguration (existingAgent) {\n    // NOTE: This check has to happen at aggregator load time\n    if (!isValid(existingAgent.info)) {\n      const cdn = gosCDN()\n      let jsAttributes = { ...cdn.info?.jsAttributes }\n      try {\n        jsAttributes = {\n          ...jsAttributes,\n          ...existingAgent.info?.jsAttributes\n        }\n      } catch (err) {\n        // do nothing\n      }\n      configure(existingAgent, {\n        ...cdn,\n        info: {\n          ...cdn.info,\n          jsAttributes\n        },\n        runtime: existingAgent.runtime\n      }, existingAgent.runtime.loaderType)\n    }\n  }\n\n  /**\n   * These are actions related to shared resources that should be initialized once by whichever feature Aggregate subclass loads first.\n   * This method should run after checkConfiguration, which may reset the agent's info/runtime object that is used here.\n   */\n  doOnceForAllAggregate (agentRef) {\n    if (!agentRef.runtime.obfuscator) agentRef.runtime.obfuscator = new Obfuscator(agentRef)\n    this.obfuscator = agentRef.runtime.obfuscator\n\n    if (!agentRef.runtime.entityManager) agentRef.runtime.entityManager = new EntityManager(this.agentRef)\n\n    if (!agentRef.runtime.harvester) agentRef.runtime.harvester = new Harvester(agentRef)\n  }\n\n  /**\n   * Report a supportability metric\n   * @param {*} metricName The tag of the name matching the Angler aggregation tag\n   * @param {*} [value] An optional value to supply. If not supplied, the metric count will be incremented by 1 for every call.\n   */\n  reportSupportabilityMetric (metricName, value) {\n    handle(SUPPORTABILITY_METRIC_CHANNEL, [metricName, value], undefined, FEATURE_NAMES.metrics, this.ee)\n  }\n}\n"],"names":["isFileProtocol","globalScope","Obfuscator","agentRef","input","rules","rule","ruleValidation","regexMissingDetected","invalidRegexDetected","invalidReplacementDetected","warn","IDEAL_PAYLOAD_SIZE","MAX_PAYLOAD_SIZE","DEFAULT_KEY","EventStoreManager","storageClass","defaultEntityGuid","featureName","#getEventStore","targetEntityGuid","eventStorage","isContainerAgentTarget","optsIfPresent","eventStore","event","dispatchGlobalEvent","activatedFeatures","type","name","params","value","opts","allPayloads","targetApp","incomingSize","isWorkerScope","origClose","task","subscribeToEOL","cb","capturePhase","isBrowserScope","subscribeToVisibilityChange","patternWithHash","patternWithoutHash","cleanURL","url","keepHash","charMap","charList","safeEncoded","real","c","qs","obj","payload","maxBytes","total","result","feature","dataArray","intermediate","next","i","stringify","param","base","getSubmitMethod","isFinalHarvest","beacon","xhr","xhrFetch","body","method","headers","objHeaders","header","sync","request","RETRY_FAILED","RETRY_SUCCEEDED","Harvester","#started","aggregateInst","harvestInterval","onHarvestInterval","localOpts","submitMethod","shouldRetryOnFail","xhrMethod","dataToSendArr","ranSend","send","FEATURE_TO_ENDPOINT","cbFinished","handle","SUPPORTABILITY_METRIC_CHANNEL","FEATURE_NAMES","warnings","endpoint","raw","cleanPayload","protocol","perceivedBeacon","RUM","baseParams","baseQueryString","payloadParams","fullUrl","EVENTS","cbResult","shouldRetry","eventListenerOpts","fetchMethod","response","status","getSubmitMethodName","clean","accumulator","key","applicationID","ref","hr","JSERRORS","ht","LOGS","BLOBS","qps","VERSION","transactionNameParam","now","EntityManager","#entities","#entityGuidLookup","entityGuid","licenseKey","x","entity","EventBuffer","#buffer","#rawBytes","#bufferBackup","#rawBytesBackup","maxPayloadSize","addSize","Aggregator","newMetrics","customParams","bucket","#getBucket","aggregateMetrics","metrics","overwriteParams","oldMetrics","oldMetric","newMetric","updateMetric","mergeMetric","types","deleteWhenRetrieved","results","hasData","metric","updateCounterMetric","createMetricObject","EventAggregator","#aggregator","#savedNamesToBuckets","aggregatorTypes","backupAggregatedDataSubset","AggregateBase","FeatureBase","agentEntityGuid","#setupEventStore","flagNames","resolve","reject","buildOutput","resp","flag","err","drain","returnedDataArr","data","existingAgent","isValid","cdn","gosCDN","jsAttributes","configure","metricName"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}