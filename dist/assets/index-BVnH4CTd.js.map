{"version":3,"file":"index-BVnH4CTd.js","sources":["../../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/trace/node.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/trace/storage.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/session_trace/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** All nodes reported to the consumer must take this shape */\nexport class TraceNode {\n  constructor(name, start, end, origin, type) {\n    this.n = name;\n    this.s = start;\n    this.e = end;\n    this.o = origin;\n    this.t = type;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope } from '../../../../common/constants/runtime';\nimport { MODE } from '../../../../common/session/constants';\nimport { now } from '../../../../common/timing/now';\nimport { parseUrl } from '../../../../common/url/parse-url';\nimport { eventOrigin } from '../../../../common/util/event-origin';\nimport { MAX_NODES_PER_HARVEST } from '../../constants';\nimport { TraceNode } from './node';\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\nconst SUPPORTS_PERFORMANCE_OBSERVER = typeof globalScope.PerformanceObserver === 'function';\nconst ignoredEvents = {\n  // we find that certain events make the data too noisy to be useful\n  global: {\n    mouseup: true,\n    mousedown: true,\n    mousemove: true\n  },\n  // certain events are present both in the window and in PVT metrics.  PVT metrics are prefered so the window events should be ignored\n  window: {\n    load: true,\n    pagehide: true\n  },\n  // when ajax instrumentation is disabled, all XMLHttpRequest events will return with origin = xhrOriginMissing and should be ignored\n  xhrOriginMissing: {\n    ignoreAll: true\n  }\n};\nconst toAggregate = {\n  typing: [1000, 2000],\n  scrolling: [100, 1000],\n  mousing: [1000, 2000],\n  touching: [1000, 2000]\n};\n\n/** The purpose of this class is to manage, normalize, and retrieve ST nodes as needed without polluting the main ST modules */\nexport class TraceStorage {\n  nodeCount = 0;\n  trace = {};\n  earliestTimeStamp = Infinity;\n  latestTimeStamp = 0;\n  prevStoredEvents = new Set();\n  #backupTrace;\n  constructor(parent) {\n    this.parent = parent;\n  }\n  #canStoreNewNode() {\n    if (this.parent.blocked) return false;\n    if (this.nodeCount >= MAX_NODES_PER_HARVEST) {\n      // limit the amount of pending data awaiting next harvest\n      if (this.parent.mode !== MODE.ERROR) return false;\n      const openedSpace = this.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // but maybe we could make some space by discarding irrelevant nodes if we're in sessioned Error mode\n      if (openedSpace === 0) return false;\n    }\n    return true;\n  }\n\n  /** Central internal function called by all the other store__ & addToTrace API to append a trace node. They MUST all have checked #canStoreNewNode before calling this func!! */\n  #storeSTN(stn) {\n    if (this.trace[stn.n]) this.trace[stn.n].push(stn);else this.trace[stn.n] = [stn];\n    if (stn.s < this.earliestTimeStamp) this.earliestTimeStamp = stn.s;\n    if (stn.s > this.latestTimeStamp) this.latestTimeStamp = stn.s;\n    this.nodeCount++;\n  }\n\n  /**\n   * Trim the collection of nodes awaiting harvest such that those seen outside a certain span of time are discarded.\n   * @param {number} lookbackDuration Past length of time until now for which we care about nodes, in milliseconds\n   * @returns {number} However many nodes were discarded after trimming.\n   */\n  trimSTNs(lookbackDuration) {\n    let prunedNodes = 0;\n    const cutoffHighResTime = Math.max(now() - lookbackDuration, 0);\n    Object.keys(this.trace).forEach(nameCategory => {\n      const nodeList = this.trace[nameCategory];\n      /* Notice nodes are appending under their name's list as they end and are stored. This means each list is already (roughly) sorted in chronological order by end time.\n         * This isn't exact since nodes go through some processing & EE handlers chain, but it's close enough as we still capture nodes whose duration overlaps the lookback window.\n         * ASSUMPTION: all 'end' timings stored are relative to timeOrigin (DOMHighResTimeStamp) and not Unix epoch based. */\n      let cutoffIdx = nodeList.findIndex(node => cutoffHighResTime <= node.e);\n      if (cutoffIdx === 0) return;else if (cutoffIdx < 0) {\n        // whole list falls outside lookback window and is irrelevant\n        cutoffIdx = nodeList.length;\n        delete this.trace[nameCategory];\n      } else nodeList.splice(0, cutoffIdx); // chop off everything outside our window i.e. before the last <lookbackDuration> timeframe\n\n      this.nodeCount -= cutoffIdx;\n      prunedNodes += cutoffIdx;\n    });\n    return prunedNodes;\n  }\n\n  /** Used by session trace's harvester to create the payload body. */\n  takeSTNs() {\n    if (!SUPPORTS_PERFORMANCE_OBSERVER) {\n      // if PO isn't supported, this checks resourcetiming buffer every harvest.\n      this.storeResources(globalScope.performance?.getEntriesByType?.('resource'));\n    }\n    const stns = Object.entries(this.trace).flatMap(([name, listOfSTNodes]) => {\n      // basically take the \"this.trace\" map-obj and concat all the list-type values\n      if (!(name in toAggregate)) return listOfSTNodes;\n      // Special processing for event nodes dealing with user inputs:\n      const reindexByOriginFn = this.smearEvtsByOrigin(name);\n      const partitionListByOriginMap = listOfSTNodes.sort((a, b) => a.s - b.s).reduce(reindexByOriginFn, {});\n      return Object.values(partitionListByOriginMap).flat(); // join the partitions back into 1-D, now ordered by origin then start time\n    }, this);\n    const earliestTimeStamp = this.earliestTimeStamp;\n    const latestTimeStamp = this.latestTimeStamp;\n    return {\n      stns,\n      earliestTimeStamp,\n      latestTimeStamp\n    };\n  }\n  smearEvtsByOrigin(name) {\n    const maxGap = toAggregate[name][0];\n    const maxLen = toAggregate[name][1];\n    const lastO = {};\n    return (byOrigin, evtNode) => {\n      let lastArr = byOrigin[evtNode.o];\n      if (!lastArr) lastArr = byOrigin[evtNode.o] = [];\n      const last = lastO[evtNode.o];\n      if (name === 'scrolling' && !trivial(evtNode)) {\n        lastO[evtNode.o] = null;\n        evtNode.n = 'scroll';\n        lastArr.push(evtNode);\n      } else if (last && evtNode.s - last.s < maxLen && last.e > evtNode.s - maxGap) {\n        last.e = evtNode.e;\n      } else {\n        lastO[evtNode.o] = evtNode;\n        lastArr.push(evtNode);\n      }\n      return byOrigin;\n    };\n    function trivial(node) {\n      const limit = 4;\n      return !!(node && typeof node.e === 'number' && typeof node.s === 'number' && node.e - node.s < limit);\n    }\n  }\n  storeNode(node) {\n    if (!this.#canStoreNewNode()) return;\n    this.#storeSTN(node);\n  }\n  processPVT(name, value, attrs) {\n    this.storeTiming({\n      [name]: value\n    });\n  }\n  storeTiming(timingEntry, isAbsoluteTimestamp = false) {\n    if (!timingEntry) return;\n\n    // loop iterates through prototype also (for FF)\n    for (let key in timingEntry) {\n      let val = timingEntry[key];\n\n      // ignore size and status type nodes that do not map to timestamp metrics\n      const lck = key.toLowerCase();\n      if (lck.indexOf('size') >= 0 || lck.indexOf('status') >= 0) continue;\n\n      // ignore inherited methods, meaningless 0 values, and bogus timestamps\n      // that are in the future (Microsoft Edge seems to sometimes produce these)\n      if (!(typeof val === 'number' && val >= 0)) continue;\n      val = Math.round(val);\n      if (this.parent.timeKeeper && this.parent.timeKeeper.ready && isAbsoluteTimestamp) {\n        val = this.parent.timeKeeper.convertAbsoluteTimestamp(Math.floor(this.parent.timeKeeper.correctAbsoluteTimestamp(val)));\n      }\n      if (!this.#canStoreNewNode()) return; // at any point when no new nodes can be stored, there's no point in processing the rest of the timing entries\n      this.#storeSTN(new TraceNode(key, val, val, 'document', 'timing'));\n    }\n  }\n\n  // Tracks the events and their listener's duration on objects wrapped by wrap-events.\n  storeEvent(currentEvent, target, start, end) {\n    if (this.shouldIgnoreEvent(currentEvent, target)) return;\n    if (!this.#canStoreNewNode()) return; // need to check if adding node will succeed BEFORE storing event ref below (*cli Jun'25 - addressing memory leak in aborted ST issue #NR-420780)\n\n    if (this.prevStoredEvents.has(currentEvent)) return; // prevent multiple listeners of an event from creating duplicate trace nodes per occurrence. Cleared every harvest. near-zero chance for re-duplication after clearing per harvest since the timestamps of the event are considered for uniqueness.\n    this.prevStoredEvents.add(currentEvent);\n    const evt = new TraceNode(this.evtName(currentEvent.type), start, end, undefined, 'event');\n    try {\n      // webcomponents-lite.js can trigger an exception on currentEvent.target getter because\n      // it does not check currentEvent.currentTarget before calling getRootNode() on it\n      evt.o = eventOrigin(currentEvent.target, target, this.parent.ee);\n    } catch (e) {\n      evt.o = eventOrigin(null, target, this.parent.ee);\n    }\n    this.#storeSTN(evt);\n  }\n  shouldIgnoreEvent(event, target) {\n    if (event.type in ignoredEvents.global) return true;\n    const origin = eventOrigin(event.target, target, this.parent.ee);\n    if (!!ignoredEvents[origin] && ignoredEvents[origin].ignoreAll) return true;\n    return !!(!!ignoredEvents[origin] && event.type in ignoredEvents[origin]);\n  }\n  evtName(type) {\n    switch (type) {\n      case 'keydown':\n      case 'keyup':\n      case 'keypress':\n        return 'typing';\n      case 'mousemove':\n      case 'mouseenter':\n      case 'mouseleave':\n      case 'mouseover':\n      case 'mouseout':\n        return 'mousing';\n      case 'scroll':\n        return 'scrolling';\n      case 'touchstart':\n      case 'touchmove':\n      case 'touchend':\n      case 'touchcancel':\n      case 'touchenter':\n      case 'touchleave':\n        return 'touching';\n      default:\n        return type;\n    }\n  }\n\n  // Tracks when the window history API specified by wrap-history is used.\n  storeHist(path, old, time) {\n    if (!this.#canStoreNewNode()) return;\n    this.#storeSTN(new TraceNode('history.pushState', time, time, path, old));\n  }\n  #laststart = 0;\n  // Processes all the PerformanceResourceTiming entries captured (by observer).\n  storeResources(resources) {\n    if (!resources || resources.length === 0) return;\n    for (let i = 0; i < resources.length; i++) {\n      const currentResource = resources[i];\n      if ((currentResource.fetchStart | 0) <= this.#laststart) continue; // don't recollect already-seen resources\n      if (!this.#canStoreNewNode()) break; // stop processing if we can't store any more resource nodes anyways\n\n      const {\n        initiatorType,\n        fetchStart,\n        responseEnd,\n        entryType\n      } = currentResource;\n      const {\n        protocol,\n        hostname,\n        port,\n        pathname\n      } = parseUrl(currentResource.name);\n      const res = new TraceNode(initiatorType, fetchStart | 0, responseEnd | 0, \"\".concat(protocol, \"://\").concat(hostname, \":\").concat(port).concat(pathname), entryType);\n      this.#storeSTN(res);\n    }\n    this.#laststart = resources[resources.length - 1].fetchStart | 0;\n  }\n\n  // JavascriptError (FEATURE) events pipes into ST here.\n  storeErrorAgg(type, name, params, metrics) {\n    if (type !== 'err') return; // internal errors are purposefully ignored\n    if (!this.#canStoreNewNode()) return;\n    this.#storeSTN(new TraceNode('error', metrics.time, metrics.time, params.message, params.stackHash));\n  }\n\n  // Ajax (FEATURE) events--XML & fetches--pipes into ST here.\n  storeXhrAgg(type, name, params, metrics) {\n    if (type !== 'xhr') return;\n    if (!this.#canStoreNewNode()) return;\n    this.#storeSTN(new TraceNode('Ajax', metrics.time, metrics.time + metrics.duration, \"\".concat(params.status, \" \").concat(params.method, \": \").concat(params.host).concat(params.pathname), 'ajax'));\n  }\n\n  /* Below are the interface expected & required of whatever storage is used across all features on an individual basis. This allows a common `.events` property on Trace shared with AggregateBase.\n    Note that the usage must be in sync with the EventStoreManager class such that AggregateBase.makeHarvestPayload can run the same regardless of which storage class a feature is using. */\n  isEmpty() {\n    return this.nodeCount === 0;\n  }\n  save() {\n    this.#backupTrace = this.trace;\n  }\n  get() {\n    return [{\n      targetApp: this.parent.agentRef.runtime.entityManager.get(),\n      data: this.takeSTNs()\n    }];\n  }\n  clear() {\n    this.trace = {};\n    this.nodeCount = 0;\n    this.prevStoredEvents.clear(); // release references to past events for GC\n    this.earliestTimeStamp = Infinity;\n    this.latestTimeStamp = 0;\n  }\n  reloadSave() {\n    for (const stnsArray of Object.values(this.#backupTrace)) {\n      for (const stn of stnsArray) {\n        if (!this.#canStoreNewNode()) return; // stop attempting to re-store nodes\n        this.#storeSTN(stn);\n      }\n    }\n  }\n  clearSave() {\n    this.#backupTrace = undefined;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { FEATURE_NAME } from '../constants';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { TraceStorage } from './trace/storage';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { MODE, SESSION_EVENTS } from '../../../common/session/constants';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { warn } from '../../../common/util/console';\nconst ERROR_MODE_SECONDS_WINDOW = 30 * 1000; // sliding window of nodes to track when simply monitoring (but not harvesting) in error mode\n/** Reserved room for query param attrs */\nconst QUERY_PARAM_PADDING = 5000;\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.harvestOpts.raw = true;\n\n    /** Tied to the entitlement flag response from BCS.  Will short circuit operations of the agg if false  */\n    this.entitled = undefined;\n    /** A flag used to decide if the 30 node threshold should be ignored on the first harvest to ensure sending on the first payload */\n    this.everHarvested = false;\n    /** If the harvest module is harvesting */\n    this.harvesting = false;\n    /** TraceStorage is the mechanism that holds, normalizes and aggregates ST nodes.  It will be accessed and purged when harvests occur */\n    this.events = new TraceStorage(this);\n\n    /* This agg needs information about sampling (sts) and entitlements (st) to make the appropriate decisions on running */\n    this.waitForFlags(['sts', 'st']).then(([stMode, stEntitled]) => this.initialize(stMode, stEntitled));\n  }\n\n  /** Sets up event listeners, and initializes this module to run in the correct \"mode\".  Can be triggered from a few places, but makes an effort to only set up listeners once */\n  initialize(stMode, stEntitled, ignoreSession) {\n    this.entitled ??= stEntitled;\n    if (!this.entitled) this.blocked = true;\n    if (this.blocked) return this.deregisterDrain();\n    if (!this.initialized) {\n      this.initialized = true;\n      /** Store session identifiers at initialization time to be cross-checked later at harvest time for session changes that are subject to race conditions */\n      this.ptid = this.agentRef.runtime.ptid;\n      this.sessionId = this.agentRef.runtime.session?.state.value;\n      // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n      this.ee.on(SESSION_EVENTS.RESET, () => {\n        if (this.blocked) return;\n        this.abort(1);\n      });\n      // The SessionEntity can have updates (locally or across tabs for SR mode changes), (across tabs for ST mode changes).\n      // Those updates should be sync'd here to ensure this page also honors the mode after initialization\n      this.ee.on(SESSION_EVENTS.UPDATE, (eventType, sessionState) => {\n        if (this.blocked) return;\n        // this will only have an effect if ST is NOT already in full mode\n        if (this.mode !== MODE.FULL && (sessionState.sessionReplayMode === MODE.FULL || sessionState.sessionTraceMode === MODE.FULL)) this.switchToFull();\n        // if another page's session entity has expired, or another page has transitioned to off and this one hasn't... we can just abort straight away here\n        if (this.sessionId !== sessionState.value || eventType === 'cross-tab' && sessionState.sessionTraceMode === MODE.OFF) this.abort(2);\n      });\n      if (typeof PerformanceNavigationTiming !== 'undefined') {\n        this.events.storeTiming(globalScope.performance?.getEntriesByType?.('navigation')[0]);\n      } else {\n        this.events.storeTiming(globalScope.performance?.timing, true);\n      }\n    }\n\n    /** ST/SR sampling flow in BCS - https://drive.google.com/file/d/19hwt2oft-8Hh4RrjpLqEXfpP_9wYBLcq/view?usp=sharing */\n    /** ST will run in the mode provided by BCS if the session IS NEW.  If not... it will use the state of the session entity to determine what mode to run in */\n    if (!this.agentRef.runtime.session.isNew && !ignoreSession) this.mode = this.agentRef.runtime.session.state.sessionTraceMode;else this.mode = stMode;\n\n    /** If the mode is off, we do not want to hold up draining for other features, so we deregister the feature for now.\n     * If it drains later (due to a mode change), data and handlers will instantly drain instead of waiting for the registry. */\n    if (this.mode === MODE.OFF) return this.deregisterDrain();\n    this.timeKeeper ??= this.agentRef.runtime.timeKeeper;\n\n    /** The handlers set up by the Inst file */\n    registerHandler('bst', (...args) => this.events.storeEvent(...args), this.featureName, this.ee);\n    registerHandler('bstResource', (...args) => this.events.storeResources(...args), this.featureName, this.ee);\n    registerHandler('bstHist', (...args) => this.events.storeHist(...args), this.featureName, this.ee);\n    registerHandler('bstXhrAgg', (...args) => this.events.storeXhrAgg(...args), this.featureName, this.ee);\n    registerHandler('bstApi', (...args) => this.events.storeNode(...args), this.featureName, this.ee);\n    registerHandler('trace-jserror', (...args) => this.events.storeErrorAgg(...args), this.featureName, this.ee);\n    registerHandler('pvtAdded', (...args) => this.events.processPVT(...args), this.featureName, this.ee);\n    if (this.mode !== MODE.FULL) {\n      /** A separate handler for noticing errors, and switching to \"full\" mode if running in \"error\" mode */\n      registerHandler('trace-jserror', () => {\n        if (this.mode === MODE.ERROR) this.switchToFull();\n      }, this.featureName, this.ee);\n    }\n    this.agentRef.runtime.session.write({\n      sessionTraceMode: this.mode\n    });\n    this.drain();\n    /** try to harvest immediately. This will not send if the trace is not running in FULL mode due to the pre-harvest checks. */\n    this.agentRef.runtime.harvester.triggerHarvestFor(this);\n  }\n  preHarvestChecks() {\n    if (this.blocked || this.mode !== MODE.FULL) return; // only allow harvest if running in full mode\n    if (!this.timeKeeper?.ready) return; // this should likely never happen, but just to be safe, we should never harvest if we cant correct time\n    if (!this.agentRef.runtime.session) return; // session entity is required for trace to run and continue running\n    if (this.sessionId !== this.agentRef.runtime.session.state.value || this.ptid !== this.agentRef.runtime.ptid) {\n      // If something unexpected happened and we somehow still got to harvesting after a session identifier changed, we should force-exit instead of harvesting:\n      this.abort(3);\n      return;\n    }\n    return true;\n  }\n  serializer({\n    stns\n  }) {\n    if (!stns.length) return; // there are no processed nodes\n    this.everHarvested = true;\n    return applyFnToProps(stns, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n  }\n  queryStringsBuilder({\n    stns,\n    earliestTimeStamp,\n    latestTimeStamp\n  }) {\n    const firstSessionHarvest = !this.agentRef.runtime.session.state.traceHarvestStarted;\n    if (firstSessionHarvest) this.agentRef.runtime.session.write({\n      traceHarvestStarted: true\n    });\n    const hasReplay = this.agentRef.runtime.session.state.sessionReplayMode === 1;\n    const endUserId = this.agentRef.info.jsAttributes['enduser.id'];\n    const entityGuid = this.agentRef.runtime.appMetadata.agents?.[0]?.entityGuid;\n\n    /* The blob consumer expects the following and will reject if not supplied:\n     * browser_monitoring_key\n     * type\n     * app_id\n     * protocol_version\n     * attributes\n     *\n     * For data that does not fit the schema of the above, it should be url-encoded and placed into `attributes`\n     */\n\n    return {\n      browser_monitoring_key: this.agentRef.info.licenseKey,\n      type: 'BrowserSessionChunk',\n      app_id: this.agentRef.info.applicationID,\n      protocol_version: '0',\n      timestamp: Math.floor(this.timeKeeper.correctRelativeTimestamp(earliestTimeStamp)),\n      attributes: encodeObj({\n        ...(entityGuid && {\n          entityGuid\n        }),\n        harvestId: \"\".concat(this.agentRef.runtime.session.state.value, \"_\").concat(this.agentRef.runtime.ptid, \"_\").concat(this.agentRef.runtime.harvestCount),\n        // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n        // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n        // trace payload metadata\n        'trace.firstTimestamp': Math.floor(this.timeKeeper.correctRelativeTimestamp(earliestTimeStamp)),\n        'trace.lastTimestamp': Math.floor(this.timeKeeper.correctRelativeTimestamp(latestTimeStamp)),\n        'trace.nodes': stns.length,\n        'trace.originTimestamp': this.timeKeeper.correctedOriginTime,\n        // other payload metadata\n        agentVersion: this.agentRef.runtime.version,\n        ...(firstSessionHarvest && {\n          firstSessionHarvest\n        }),\n        ...(hasReplay && {\n          hasReplay\n        }),\n        ptid: \"\".concat(this.ptid),\n        session: \"\".concat(this.sessionId),\n        // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n        ...(endUserId && {\n          'enduser.id': this.obfuscator.obfuscateString(endUserId)\n        }),\n        currentUrl: this.obfuscator.obfuscateString(cleanURL('' + location))\n        // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n      }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n    };\n  }\n\n  /** Switch from \"off\" or \"error\" to full mode (if entitled) */\n  switchToFull() {\n    if (this.mode === MODE.FULL || !this.entitled || this.blocked) return;\n    const prevMode = this.mode;\n    this.mode = MODE.FULL;\n    this.agentRef.runtime.session.write({\n      sessionTraceMode: this.mode\n    });\n    if (prevMode === MODE.OFF || !this.initialized) return this.initialize(this.mode, this.entitled);\n    if (this.initialized) {\n      this.events.trimSTNs(ERROR_MODE_SECONDS_WINDOW); // up until now, Trace would've been just buffering nodes up to max, which needs to be trimmed to last X seconds\n      this.agentRef.runtime.harvester.triggerHarvestFor(this);\n    }\n  }\n\n  /** Stop running for the remainder of the page lifecycle */\n  abort(code) {\n    warn(60, code);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.agentRef.runtime.session.write({\n      sessionTraceMode: this.mode\n    });\n    this.events.clear();\n  }\n}"],"names":["TraceNode","name","start","end","origin","type","ERROR_MODE_SECONDS_WINDOW","SUPPORTS_PERFORMANCE_OBSERVER","globalScope","ignoredEvents","toAggregate","TraceStorage","#backupTrace","parent","#canStoreNewNode","MAX_NODES_PER_HARVEST","MODE","#storeSTN","stn","lookbackDuration","prunedNodes","cutoffHighResTime","now","nameCategory","nodeList","cutoffIdx","node","stns","listOfSTNodes","reindexByOriginFn","partitionListByOriginMap","a","b","earliestTimeStamp","latestTimeStamp","maxGap","maxLen","lastO","byOrigin","evtNode","lastArr","last","trivial","value","attrs","timingEntry","isAbsoluteTimestamp","key","val","lck","currentEvent","target","evt","eventOrigin","event","path","old","time","#laststart","resources","currentResource","initiatorType","fetchStart","responseEnd","entryType","protocol","hostname","port","pathname","parseUrl","res","params","metrics","stnsArray","QUERY_PARAM_PADDING","Aggregate","AggregateBase","FEATURE_NAME","agentRef","stMode","stEntitled","ignoreSession","SESSION_EVENTS","eventType","sessionState","registerHandler","args","applyFnToProps","firstSessionHarvest","hasReplay","endUserId","entityGuid","encodeObj","cleanURL","prevMode","code","warn"],"mappings":"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","x_google_ignoreList":[0,1,2]}