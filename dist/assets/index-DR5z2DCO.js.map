{"version":3,"file":"index-DR5z2DCO.js","sources":["../../node_modules/@newrelic/browser-agent/dist/esm/features/logging/shared/log.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/logging/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { initialLocation } from '../../../common/constants/runtime';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { LOG_LEVELS } from '../constants';\nexport class Log {\n  /** @type {long} the unix timestamp of the log event */\n  timestamp;\n  /** @type {string} the log message */\n  message;\n  /** @type {object} the object of attributes to be parsed by logging ingest into top-level properties */\n  attributes;\n  /** @type {'ERROR'|'TRACE'|'DEBUG'|'INFO'|'WARN'} the log type of the log */\n  level;\n\n  /**\n   * @param {number} timestamp - Unix timestamp\n   * @param {string} message - message string\n   * @param {object} attributes - other log event attributes\n   * @param {enum} level - Log level\n   */\n  constructor(timestamp, message, attributes = {}, level = LOG_LEVELS.INFO) {\n    /** @type {long} */\n    this.timestamp = timestamp;\n    this.message = message;\n    this.attributes = {\n      ...attributes,\n      pageUrl: cleanURL('' + initialLocation)\n    };\n    this.level = level.toUpperCase();\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { warn } from '../../../common/util/console';\nimport { stringify } from '../../../common/util/stringify';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { FEATURE_NAME, LOGGING_EVENT_EMITTER_CHANNEL, LOG_LEVELS, LOGGING_MODE } from '../constants';\nimport { Log } from '../shared/log';\nimport { isValidLogLevel } from '../shared/utils';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { MAX_PAYLOAD_SIZE } from '../../../common/constants/agent-constants';\nimport { isContainerAgentTarget } from '../../../common/util/target';\nimport { SESSION_EVENT_TYPES, SESSION_EVENTS } from '../../../common/session/constants';\nimport { ABORT_REASONS } from '../../session_replay/constants';\nimport { canEnableSessionTracking } from '../../utils/feature-gates';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.isSessionTrackingEnabled = canEnableSessionTracking(agentRef.init) && agentRef.runtime.session;\n\n    // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n    this.ee.on(SESSION_EVENTS.RESET, () => {\n      this.abort(ABORT_REASONS.RESET);\n    });\n    this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n      if (this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n      if (this.loggingMode !== LOGGING_MODE.OFF && data.loggingMode === LOGGING_MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);else this.loggingMode = data.loggingMode;\n    });\n    this.harvestOpts.raw = true;\n    this.waitForFlags(['log']).then(([loggingMode]) => {\n      const session = this.agentRef.runtime.session ?? {};\n      if (this.loggingMode === LOGGING_MODE.OFF || session.isNew && loggingMode === LOGGING_MODE.OFF) {\n        this.blocked = true;\n        this.deregisterDrain();\n        return;\n      }\n      if (session.isNew || !this.isSessionTrackingEnabled) {\n        this.updateLoggingMode(loggingMode);\n      } else {\n        this.loggingMode = session.state.loggingMode;\n      }\n\n      /** emitted by instrument class (wrapped loggers) or the api methods directly */\n      registerHandler(LOGGING_EVENT_EMITTER_CHANNEL, this.handleLog.bind(this), this.featureName, this.ee);\n      this.drain();\n      /** harvest immediately once started to purge pre-load logs collected */\n      agentRef.runtime.harvester.triggerHarvestFor(this);\n    });\n  }\n  updateLoggingMode(loggingMode) {\n    this.loggingMode = loggingMode;\n    this.syncWithSessionManager({\n      loggingMode: this.loggingMode\n    });\n  }\n  handleLog(timestamp, message, attributes = {}, level = LOG_LEVELS.INFO, targetEntityGuid) {\n    if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return warn(56, this.featureName);\n    if (this.blocked || !this.loggingMode) return;\n    if (!attributes || typeof attributes !== 'object') attributes = {};\n    if (typeof level === 'string') level = level.toUpperCase();\n    if (!isValidLogLevel(level)) return warn(30, level);\n    if (this.loggingMode < (LOGGING_MODE[level] || Infinity)) {\n      this.reportSupportabilityMetric('Logging/Event/Dropped/Sampling');\n      return;\n    }\n    try {\n      if (typeof message !== 'string') {\n        const stringified = stringify(message);\n        /**\n           * Error instances convert to `{}` when stringified\n           * Symbol converts to '' when stringified\n           * other cases tbd\n           * */\n        if (!!stringified && stringified !== '{}') message = stringified;else message = String(message);\n      }\n    } catch (err) {\n      warn(16, message);\n      this.reportSupportabilityMetric('Logging/Event/Dropped/Casting');\n      return;\n    }\n    if (typeof message !== 'string' || !message) return warn(32);\n    const log = new Log(Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp)), message, attributes, level);\n    const logBytes = log.message.length + stringify(log.attributes).length + log.level.length + 10; // timestamp == 10 chars\n\n    const failToHarvestMessage = 'Logging/Harvest/Failed/Seen';\n    if (logBytes > MAX_PAYLOAD_SIZE) {\n      // cannot possibly send this, even with an empty buffer\n      this.reportSupportabilityMetric(failToHarvestMessage, logBytes);\n      warn(31, log.message.slice(0, 25) + '...');\n      return;\n    }\n    if (this.events.wouldExceedMaxSize(logBytes, targetEntityGuid)) {\n      this.reportSupportabilityMetric('Logging/Harvest/Early/Seen', this.events.byteSize() + logBytes);\n      this.agentRef.runtime.harvester.triggerHarvestFor(this, {\n        targetEntityGuid\n      }); // force a harvest synchronously to try adding again\n    }\n    if (!this.events.add(log, targetEntityGuid)) {\n      // still failed after a harvest attempt despite not being too large would mean harvest failed with options.retry\n      this.reportSupportabilityMetric(failToHarvestMessage, logBytes);\n      warn(31, log.message.slice(0, 25) + '...');\n    } else {\n      this.reportSupportabilityMetric('Logging/Event/Added/Seen');\n    }\n  }\n  serializer(eventBuffer, targetEntityGuid) {\n    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);\n    const sessionEntity = this.agentRef.runtime.session;\n    return [{\n      common: {\n        /** Attributes in the `common` section are added to `all` logs generated in the payload */\n        attributes: {\n          'entity.guid': target.entityGuid,\n          // browser entity guid as provided API target OR the default from RUM response if not supplied\n          ...(sessionEntity && {\n            session: sessionEntity.state.value || '0',\n            // The session ID that we generate and keep across page loads\n            hasReplay: sessionEntity.state.sessionReplayMode === 1 && isContainerAgentTarget(target, this.agentRef),\n            // True if a session replay recording is running\n            hasTrace: sessionEntity.state.sessionTraceMode === 1 // True if a session trace recording is running\n          }),\n          ptid: this.agentRef.runtime.ptid,\n          // page trace id\n          appId: target.applicationID || this.agentRef.info.applicationID,\n          // Application ID from info object,\n          standalone: Boolean(this.agentRef.info.sa),\n          // copy paste (true) vs APM (false)\n          agentVersion: this.agentRef.runtime.version,\n          // browser agent version\n          // The following 3 attributes are evaluated and dropped at ingest processing time and do not get stored on NRDB:\n          'instrumentation.provider': 'browser',\n          'instrumentation.version': this.agentRef.runtime.version,\n          'instrumentation.name': this.agentRef.runtime.loaderType,\n          // Custom attributes\n          ...this.agentRef.info.jsAttributes\n        }\n      },\n      /** logs section contains individual unique log entries */\n      logs: applyFnToProps(eventBuffer, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string')\n    }];\n  }\n  queryStringsBuilder(_, targetEntityGuid) {\n    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);\n    return {\n      browser_monitoring_key: target.licenseKey\n    };\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort(reason = {}) {\n    this.reportSupportabilityMetric(\"Logging/Abort/\".concat(reason.sm));\n    this.blocked = true;\n    if (this.events) {\n      this.events.clear();\n      this.events.clearSave();\n    }\n    this.updateLoggingMode(LOGGING_MODE.OFF);\n    this.deregisterDrain();\n  }\n  syncWithSessionManager(state = {}) {\n    if (this.isSessionTrackingEnabled) {\n      this.agentRef.runtime.session.write(state);\n    }\n  }\n}"],"names":["Log","timestamp","message","attributes","level","LOG_LEVELS","cleanURL","initialLocation","Aggregate","AggregateBase","FEATURE_NAME","agentRef","canEnableSessionTracking","SESSION_EVENTS","ABORT_REASONS","type","data","SESSION_EVENT_TYPES","LOGGING_MODE","loggingMode","session","registerHandler","LOGGING_EVENT_EMITTER_CHANNEL","targetEntityGuid","warn","isValidLogLevel","stringified","stringify","log","logBytes","failToHarvestMessage","MAX_PAYLOAD_SIZE","eventBuffer","target","sessionEntity","isContainerAgentTarget","applyFnToProps","_","reason","state"],"mappings":"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","x_google_ignoreList":[0,1]}