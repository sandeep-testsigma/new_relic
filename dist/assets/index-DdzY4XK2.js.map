{"version":3,"file":"index-DdzY4XK2.js","sources":["../../node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/bel-node.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/ajax-node.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/interaction.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/initial-page-load-interaction.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/soft_navigations/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nlet nodesSeen = 0;\nexport class BelNode {\n  belType;\n  /** List of other BelNode derivatives. Each children should be of a subclass that implements its own 'serialize' function. */\n  children = [];\n  start;\n  end;\n  callbackEnd = 0;\n  callbackDuration = 0;\n  nodeId = ++nodesSeen;\n  constructor(agentRef) {\n    this.obfuscator = agentRef.runtime.obfuscator;\n    this.info = agentRef.info;\n  }\n  addChild(child) {\n    this.children.push(child);\n  }\n\n  /** Virtual fn for stringifying an instance. */\n  serialize() {}\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { addCustomAttributes, getAddStringContext, nullable, numeric } from '../../../common/serialize/bel-serializer';\nimport { NODE_TYPE } from '../constants';\nimport { BelNode } from './bel-node';\nexport class AjaxNode extends BelNode {\n  constructor(agentRef, ajaxEvent) {\n    super(agentRef);\n    this.belType = NODE_TYPE.AJAX;\n    this.method = ajaxEvent.method;\n    this.status = ajaxEvent.status;\n    this.domain = ajaxEvent.domain;\n    this.path = ajaxEvent.path;\n    this.txSize = ajaxEvent.requestSize;\n    this.rxSize = ajaxEvent.responseSize;\n    this.requestedWith = ajaxEvent.type === 'fetch' ? 1 : ''; // 'xhr' and 'beacon' types get the empty string\n    this.spanId = ajaxEvent.spanId;\n    this.traceId = ajaxEvent.traceId;\n    this.spanTimestamp = ajaxEvent.spanTimestamp;\n    this.gql = ajaxEvent.gql;\n    this.start = ajaxEvent.startTime; // 5000 --- 5500 --> 10500\n    this.end = ajaxEvent.endTime;\n  }\n  serialize(parentStartTimestamp) {\n    const addString = getAddStringContext(this.obfuscator);\n    const nodeList = [];\n\n    // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n    const fields = [numeric(this.belType), 0,\n    // this will be overwritten below with number of attached nodes\n    numeric(this.start - parentStartTimestamp),\n    // start relative to parent start (if part of first node in payload) or first parent start\n    numeric(this.end - this.start),\n    // end is relative to start\n    numeric(this.callbackEnd), numeric(this.callbackDuration), addString(this.method), numeric(this.status), addString(this.domain), addString(this.path), numeric(this.txSize), numeric(this.rxSize), this.requestedWith, addString(this.nodeId), nullable(this.spanId, addString, true) + nullable(this.traceId, addString, true) + nullable(this.spanTimestamp, numeric)];\n    let allAttachedNodes = [];\n    if (typeof this.gql === 'object') allAttachedNodes = addCustomAttributes(this.gql, addString);\n    this.children.forEach(node => allAttachedNodes.push(node.serialize())); // no children is expected under ajax nodes at this time\n\n    fields[1] = numeric(allAttachedNodes.length);\n    nodeList.push(fields);\n    if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n    return nodeList.join(';');\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { globalScope, initialLocation } from '../../../common/constants/runtime';\nimport { generateUuid } from '../../../common/ids/unique-id';\nimport { addCustomAttributes, getAddStringContext, nullable, numeric } from '../../../common/serialize/bel-serializer';\nimport { now } from '../../../common/timing/now';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { NODE_TYPE, INTERACTION_STATUS, INTERACTION_TYPE, API_TRIGGER_NAME, IPL_TRIGGER_NAME } from '../constants';\nimport { BelNode } from './bel-node';\n\n/**\n * link https://github.com/newrelic/nr-querypack/blob/main/schemas/bel/7.qpschema\n **/\nexport class Interaction extends BelNode {\n  id = generateUuid(); // unique id that is serialized and used to link interactions with errors\n  initialPageURL = initialLocation;\n  customName;\n  customAttributes = {};\n  customDataByApi = {};\n  queueTime; // only used by initialPageLoad interactions\n  appTime; // only used by initialPageLoad interactions\n  newRoute;\n  /** Internal state of this interaction: in-progress, finished, or cancelled. */\n  status = INTERACTION_STATUS.IP;\n  domTimestamp = 0;\n  historyTimestamp = 0;\n  createdByApi = false;\n  keepOpenUntilEndApi = false;\n  onDone = [];\n  cancellationTimer;\n  constructor(agentRef, uiEvent, uiEventTimestamp, currentRouteKnown, currentUrl) {\n    super(agentRef);\n    this.belType = NODE_TYPE.INTERACTION;\n    this.trigger = uiEvent;\n    this.start = uiEventTimestamp;\n    this.oldRoute = currentRouteKnown;\n    this.eventSubscription = new Map([['finished', []], ['cancelled', []]]);\n    this.forceSave = this.forceIgnore = false;\n    if (this.trigger === API_TRIGGER_NAME) this.createdByApi = true;\n    this.newURL = this.oldURL = currentUrl || globalScope?.location.href;\n  }\n  updateDom(timestamp) {\n    this.domTimestamp = timestamp || now(); // default timestamp should be precise for accurate isActiveDuring calculations\n  }\n  updateHistory(timestamp, newUrl) {\n    this.newURL = newUrl || '' + globalScope?.location;\n    this.historyTimestamp = timestamp || now();\n  }\n  seenHistoryAndDomChange() {\n    return this.historyTimestamp > 0 && this.domTimestamp > this.historyTimestamp; // URL must change before DOM does\n  }\n  on(event, cb) {\n    if (!this.eventSubscription.has(event)) throw new Error('Cannot subscribe to non pre-defined events.');\n    if (typeof cb !== 'function') throw new Error('Must supply function as callback.');\n    this.eventSubscription.get(event).push(cb);\n  }\n  done(customEndTime) {\n    // User could've mark this interaction--regardless UI or api started--as \"don't close until .end() is called on it\". Only .end provides a timestamp; the default flows do not.\n    if (this.keepOpenUntilEndApi && customEndTime === undefined) return false;\n    // If interaction is already closed, this is a no-op. However, returning true lets startUIInteraction know that it CAN start a new interaction, as this one is done.\n    if (this.status !== INTERACTION_STATUS.IP) return true;\n    this.onDone.forEach(apiProvidedCb => apiProvidedCb(this.customDataByApi)); // this interaction's .save or .ignore can still be set by these user provided callbacks for example\n\n    if (this.forceIgnore) this.#cancel(); // .ignore() always has precedence over save actions\n    else if (this.seenHistoryAndDomChange()) this.#finish(customEndTime); // then this should've already finished while it was the interactionInProgress, with a natural end time\n    else if (this.forceSave) this.#finish(customEndTime || performance.now()); // a manually saved ixn (did not fulfill conditions) must have a specified end time, if one wasn't provided\n    else this.#cancel();\n    return true;\n  }\n  #finish(customEndTime = 0) {\n    clearTimeout(this.cancellationTimer);\n    this.end = Math.max(this.domTimestamp, this.historyTimestamp, customEndTime);\n    this.customAttributes = {\n      ...this.info.jsAttributes,\n      ...this.customAttributes\n    }; // attrs specific to this interaction should have precedence over the general custom attrs\n    this.status = INTERACTION_STATUS.FIN;\n\n    // Run all the callbacks awaiting this interaction to finish.\n    const callbacks = this.eventSubscription.get('finished');\n    callbacks.forEach(fn => fn());\n  }\n  #cancel() {\n    clearTimeout(this.cancellationTimer);\n    this.status = INTERACTION_STATUS.CAN;\n\n    // Run all the callbacks listening to this interaction's potential cancellation.\n    const callbacks = this.eventSubscription.get('cancelled');\n    callbacks.forEach(fn => fn());\n  }\n\n  /**\n   * Given a timestamp, determine if it falls within this interaction's span, i.e. if this was the active interaction during that time.\n   * For in-progress interactions, this only compares the time with the start of span. Cancelled interactions are not considered active at all.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns True or false boolean.\n   */\n  isActiveDuring(timestamp) {\n    if (this.status === INTERACTION_STATUS.IP) return this.start <= timestamp;\n    return this.status === INTERACTION_STATUS.FIN && this.start <= timestamp && this.end > timestamp;\n  }\n\n  // Following are virtual properties overridden by a subclass:\n  get firstPaint() {}\n  get firstContentfulPaint() {}\n  get navTiming() {}\n  serialize(firstStartTimeOfPayload) {\n    const isFirstIxnOfPayload = firstStartTimeOfPayload === undefined;\n    const addString = getAddStringContext(this.obfuscator);\n    const nodeList = [];\n    let ixnType;\n    if (this.trigger === IPL_TRIGGER_NAME) ixnType = INTERACTION_TYPE.INITIAL_PAGE_LOAD;else if (this.newURL !== this.oldURL) ixnType = INTERACTION_TYPE.ROUTE_CHANGE;else ixnType = INTERACTION_TYPE.UNSPECIFIED;\n\n    // IMPORTANT: The order in which addString is called matters and correlates to the order in which string shows up in the harvest payload. Do not re-order the following code.\n    const fields = [numeric(this.belType), 0,\n    // this will be overwritten below with number of attached nodes\n    numeric(this.start - (isFirstIxnOfPayload ? 0 : firstStartTimeOfPayload)),\n    // the very 1st ixn does not require offset so it should fallback to a 0 while rest is offset by the very 1st ixn's start\n    numeric(this.end - this.start),\n    // end -- relative to start\n    numeric(this.callbackEnd),\n    // cbEnd -- relative to start; not used by BrowserInteraction events\n    numeric(this.callbackDuration),\n    // not relative\n    addString(this.trigger), addString(cleanURL(this.initialPageURL, true)), addString(cleanURL(this.oldURL, true)), addString(cleanURL(this.newURL, true)), addString(this.customName), ixnType, nullable(this.queueTime, numeric, true) + nullable(this.appTime, numeric, true) + nullable(this.oldRoute, addString, true) + nullable(this.newRoute, addString, true) + addString(this.id), addString(this.nodeId), nullable(this.firstPaint, numeric, true) + nullable(this.firstContentfulPaint, numeric)];\n    const allAttachedNodes = addCustomAttributes(this.customAttributes || {}, addString); // start with all custom attributes\n    if (this.info.atts) allAttachedNodes.push('a,' + addString(this.info.atts)); // add apm provided attributes\n    /* Querypack encoder+decoder quirkiness:\n       - If first ixn node of payload is being processed, its children's start time must be offset by this node's start. (firstStartTime should be undefined.)\n       - Else for subsequent ixns in the same payload, we go back to using that first ixn node's start to offset their children's start. */\n    this.children.forEach(node => allAttachedNodes.push(node.serialize(isFirstIxnOfPayload ? this.start : firstStartTimeOfPayload))); // recursively add the serialized string of every child of this (ixn) bel node\n\n    fields[1] = numeric(allAttachedNodes.length);\n    nodeList.push(fields);\n    if (allAttachedNodes.length) nodeList.push(allAttachedNodes.join(';'));\n    if (this.navTiming) nodeList.push(this.navTiming);else nodeList.push('');\n    // nodeList = [<fields array>, <serialized string of all attributes and children>, <serialized nav timing info> || '']\n\n    return nodeList.join(';');\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { navTimingValues } from '../../../common/timing/nav-timing';\nimport { Interaction } from './interaction';\nimport { numeric } from '../../../common/serialize/bel-serializer';\nimport { firstPaint } from '../../../common/vitals/first-paint';\nimport { firstContentfulPaint } from '../../../common/vitals/first-contentful-paint';\nimport { IPL_TRIGGER_NAME } from '../constants';\nexport class InitialPageLoadInteraction extends Interaction {\n  constructor(agentRef) {\n    super(agentRef, IPL_TRIGGER_NAME, 0, null);\n    this.queueTime = agentRef.info.queueTime;\n    this.appTime = agentRef.info.applicationTime;\n    this.oldURL = document.referrer;\n  }\n  get firstPaint() {\n    return firstPaint.current.value;\n  }\n  get firstContentfulPaint() {\n    return firstContentfulPaint.current.value;\n  }\n\n  /**\n   * Build the navTiming node. This assumes the navTimingValues array in nav-timing.js has already been filled with values via the PageViewEvent feature having\n   * executed the addPT function first and foremost.\n   */\n  get navTiming() {\n    if (!navTimingValues.length) return;\n    /*\n    1. we initialize the seperator to ',' (seperates the nodeType id from the first value)\n    2. we initialize the navTiming node to 'b' (the nodeType id)\n    3. if the value is present, we add the seperator followed by the value;\n       otherwise:\n        - we add null seperator ('!') to the navTimingNode\n        - we set the seperator to an empty string since we already wrote it above\n      the reason for writing the null seperator instead of setting the seperator\n      is to ensure we still write it if the null is the last navTiming value.\n    */\n    let seperator = ',';\n    let navTimingNode = 'b';\n    let prev = 0;\n\n    // Get all navTiming values except offset aka timeOrigin since we just consider that (this.start) 0.\n    // These are the latter 20 of the 21 timings appended by addPT:\n    navTimingValues.slice(1, 21).forEach(v => {\n      if (v !== undefined) {\n        navTimingNode += seperator + numeric(v - prev);\n        seperator = ',';\n        prev = v;\n      } else {\n        navTimingNode += seperator + '!';\n        seperator = '';\n      }\n    });\n    return navTimingNode;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { handle } from '../../../common/event-emitter/handle';\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { single } from '../../../common/util/invoke';\nimport { timeToFirstByte } from '../../../common/vitals/time-to-first-byte';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { API_TRIGGER_NAME, FEATURE_NAME, INTERACTION_STATUS, INTERACTION_TRIGGERS, IPL_TRIGGER_NAME } from '../constants';\nimport { AjaxNode } from './ajax-node';\nimport { InitialPageLoadInteraction } from './initial-page-load-interaction';\nimport { Interaction } from './interaction';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef, {\n    domObserver\n  }) {\n    super(agentRef, FEATURE_NAME);\n    this.interactionsToHarvest = this.events;\n    this.domObserver = domObserver;\n    this.initialPageLoadInteraction = new InitialPageLoadInteraction(agentRef);\n    this.initialPageLoadInteraction.onDone.push(() => {\n      // this ensures the .end() method also works with iPL\n      if (agentRef.runtime.session?.isNew) this.initialPageLoadInteraction.customAttributes.isFirstOfSession = true; // mark the hard page load as first of its session\n      this.initialPageLoadInteraction.forceSave = true; // unless forcibly ignored, iPL always finish by default\n      const ixn = this.initialPageLoadInteraction;\n      this.interactionsToHarvest.add(ixn);\n      this.initialPageLoadInteraction = null;\n    });\n    timeToFirstByte.subscribe(({\n      attrs\n    }) => {\n      const loadEventTime = attrs.navigationEntry.loadEventEnd;\n      this.initialPageLoadInteraction.done(loadEventTime);\n      // Report metric on the initial page load time\n      this.reportSupportabilityMetric('SoftNav/Interaction/InitialPageLoad/Duration/Ms', Math.round(loadEventTime));\n    });\n    this.latestRouteSetByApi = null;\n    this.interactionInProgress = null; // aside from the \"page load\" interaction, there can only ever be 1 ongoing at a time\n    this.latestHistoryUrl = null;\n    this.harvestOpts.beforeUnload = () => this.interactionInProgress?.done(); // return any withheld ajax or jserr events so they can be sent with EoL harvest\n\n    this.waitForFlags(['spa']).then(([spaOn]) => {\n      if (spaOn) {\n        this.drain();\n        setTimeout(() => agentRef.runtime.harvester.triggerHarvestFor(this), 0); // send the IPL ixn on next tick, giving some time for any ajax to finish; we may want to just remove this?\n      } else {\n        this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n        this.deregisterDrain();\n      }\n    });\n\n    // By default, a complete UI driven interaction requires event -> URL change -> DOM mod in that exact order.\n    registerHandler('newUIEvent', event => this.startUIInteraction(event.type, Math.floor(event.timeStamp), event.target), this.featureName, this.ee);\n    registerHandler('newURL', (timestamp, url) => {\n      // In the case of 'popstate' trigger, by the time the event fires, the URL has already changed, so we need to store what-will-be the *previous* URL for oldURL of next popstate ixn.\n      this.latestHistoryUrl = url;\n      this.interactionInProgress?.updateHistory(timestamp, url);\n    }, this.featureName, this.ee);\n    registerHandler('newDom', timestamp => {\n      this.interactionInProgress?.updateDom(timestamp);\n      if (this.interactionInProgress?.seenHistoryAndDomChange()) this.interactionInProgress.done();\n    }, this.featureName, this.ee);\n    this.#registerApiHandlers();\n    registerHandler('ajax', this.#handleAjaxEvent.bind(this), this.featureName, this.ee);\n    registerHandler('jserror', this.#handleJserror.bind(this), this.featureName, this.ee);\n  }\n  serializer(eventBuffer) {\n    // The payload depacker takes the first ixn of a payload (if there are multiple ixns) and positively offset the subsequent ixns timestamps by that amount.\n    // In order to accurately portray the real start & end times of the 2nd & onward ixns, we hence need to negatively offset their start timestamps with that of the 1st ixn.\n    let firstIxnStartTime;\n    const serializedIxnList = [];\n    for (const interaction of eventBuffer) {\n      serializedIxnList.push(interaction.serialize(firstIxnStartTime));\n      if (firstIxnStartTime === undefined) firstIxnStartTime = Math.floor(interaction.start); // careful not to match or overwrite on 0 value!\n    }\n    return \"bel.7;\".concat(serializedIxnList.join(';'));\n  }\n  startUIInteraction(eventName, startedAt, sourceElem) {\n    // this is throttled by instrumentation so that it isn't excessively called\n    if (this.interactionInProgress?.createdByApi) return; // api-started interactions cannot be disrupted aka cancelled by UI events (and the vice versa applies as well)\n    if (this.interactionInProgress?.done() === false) return; // current in-progress is blocked from closing, e.g. by 'waitForEnd' api option\n\n    const oldURL = eventName === INTERACTION_TRIGGERS[3] ? this.latestHistoryUrl : undefined; // see related comment in 'newURL' handler above, 'popstate'\n    this.interactionInProgress = new Interaction(this.agentRef, eventName, startedAt, this.latestRouteSetByApi, oldURL);\n    if (eventName === INTERACTION_TRIGGERS[0]) {\n      // 'click'\n      const sourceElemText = getActionText(sourceElem);\n      if (sourceElemText) this.interactionInProgress.customAttributes.actionText = sourceElemText;\n    }\n    this.interactionInProgress.cancellationTimer = setTimeout(() => {\n      this.interactionInProgress.done();\n      // Report metric on frequency of cancellation due to timeout for UI ixn\n      this.reportSupportabilityMetric('SoftNav/Interaction/TimeOut');\n    }, 30000); // UI ixn are disregarded after 30 seconds if it's not completed by then\n    this.setClosureHandlers();\n  }\n  setClosureHandlers() {\n    this.interactionInProgress.on('finished', () => {\n      const ref = this.interactionInProgress;\n      this.interactionsToHarvest.add(this.interactionInProgress);\n      this.interactionInProgress = null;\n      this.domObserver.disconnect(); // can stop observing whenever our interaction logic completes a cycle\n\n      // Report metric on the ixn duration\n      this.reportSupportabilityMetric(\"SoftNav/Interaction/\".concat(ref.newURL !== ref.oldURL ? 'RouteChange' : 'Custom', \"/Duration/Ms\"), Math.round(ref.end - ref.start));\n    });\n    this.interactionInProgress.on('cancelled', () => {\n      this.interactionInProgress = null;\n      this.domObserver.disconnect();\n    });\n  }\n\n  /**\n   * Find the active interaction (current or past) for a given timestamp. Note that historic lookups mostly only go as far back as the last harvest for this feature.\n   * Also, the caller should check the status of the interaction returned if found via {@link Interaction.status}, if that's pertinent.\n   * TIP: Cancelled (status) interactions are NOT returned!\n   * IMPORTANT: Finished interactions are in queue for next harvest! It's highly recommended that consumer logic be synchronous for safe reference.\n   * @param {DOMHighResTimeStamp} timestamp\n   * @returns An {@link Interaction} or undefined, if no active interaction was found.\n   */\n  getInteractionFor(timestamp) {\n    /* In the sole case wherein there can be two \"interactions\" overlapping (initialPageLoad + regular route-change),\n      the regular interaction should get precedence in being assigned the \"active\" interaction in regards to our one-at-a-time model.\n    */\n    if (this.interactionInProgress?.isActiveDuring(timestamp)) return this.interactionInProgress;\n    let saveIxn;\n    const [{\n      data: interactionsBuffer\n    }] = this.interactionsToHarvest.get();\n    for (let idx = interactionsBuffer.length - 1; idx >= 0; idx--) {\n      // reverse search for the latest completed interaction for efficiency\n      const finishedInteraction = interactionsBuffer[idx];\n      if (finishedInteraction.isActiveDuring(timestamp)) {\n        if (finishedInteraction.trigger !== IPL_TRIGGER_NAME) return finishedInteraction;\n        // It's possible that a complete interaction occurs before page is fully loaded, so we need to consider if a route-change ixn may have overlapped this iPL\n        else saveIxn = finishedInteraction;\n      }\n    }\n    if (saveIxn) return saveIxn; // if an iPL was determined to be active and no route-change was found active for the same time, then iPL is deemed the one\n    if (this.initialPageLoadInteraction?.isActiveDuring(timestamp)) return this.initialPageLoadInteraction; // lowest precedence and also only if it's still in-progress\n    // Time must be when no interaction is happening, so return undefined.\n  }\n\n  /**\n   * Handles or redirect ajax event based on the interaction, if any, that it's tied to.\n   * @param {Object} event see Ajax feature's storeXhr function for object definition\n   */\n  #handleAjaxEvent(event) {\n    const associatedInteraction = this.getInteractionFor(event.startTime);\n    if (!associatedInteraction) {\n      // no interaction was happening when this ajax started, so give it back to Ajax feature for processing\n      handle('returnAjax', [event], undefined, FEATURE_NAMES.ajax, this.ee);\n    } else {\n      if (associatedInteraction.status === INTERACTION_STATUS.FIN) processAjax(this.agentRef, event, associatedInteraction); // tack ajax onto the ixn object awaiting harvest\n      else {\n        // same thing as above, just at a later time -- if the interaction in progress is cancelled, just send the event back to ajax feat unmodified\n        associatedInteraction.on('finished', () => processAjax(this.agentRef, event, associatedInteraction));\n        associatedInteraction.on('cancelled', () => handle('returnAjax', [event], undefined, FEATURE_NAMES.ajax, this.ee));\n      }\n    }\n    function processAjax(agent, event, parentInteraction) {\n      const newNode = new AjaxNode(agent, event);\n      parentInteraction.addChild(newNode);\n    }\n  }\n\n  /**\n   * Decorate the passed-in params obj with properties relating to any associated interaction at the time of the timestamp.\n   * @param {Object} params reference to the local var instance in Jserrors feature's storeError\n   * @param {DOMHighResTimeStamp} timestamp time the jserror occurred\n   */\n  #handleJserror(params, timestamp) {\n    const associatedInteraction = this.getInteractionFor(timestamp);\n    if (!associatedInteraction) return; // do not need to decorate this jserror params\n\n    // Whether the interaction is in-progress or already finished, the id will let jserror buffer it under its index, until it gets the next step instruction.\n    params.browserInteractionId = associatedInteraction.id;\n    if (associatedInteraction.status === INTERACTION_STATUS.FIN) {\n      // This information cannot be relayed back via handle() that flushes buffered errs because this is being called by a jserror's handle() per se and before the err is buffered.\n      params._softNavFinished = true; // instead, signal that this err can be processed right away without needing to be buffered aka wait for an in-progress ixn\n      params._softNavAttributes = associatedInteraction.customAttributes;\n    } else {\n      // These callbacks may be added multiple times for an ixn, but just a single run will deal with all jserrors associated with the interaction.\n      // As such, be cautious not to use the params object since that's tied to one specific jserror and won't affect the rest of them.\n      associatedInteraction.on('finished', single(() => handle('softNavFlush', [associatedInteraction.id, true, associatedInteraction.customAttributes], undefined, FEATURE_NAMES.jserrors, this.ee)));\n      associatedInteraction.on('cancelled', single(() => handle('softNavFlush', [associatedInteraction.id, false, undefined], undefined, FEATURE_NAMES.jserrors, this.ee))); // don't take custom attrs from cancelled ixns\n    }\n  }\n  #registerApiHandlers() {\n    const INTERACTION_API = 'api-ixn-';\n    const thisClass = this;\n    registerHandler(INTERACTION_API + 'get', function (time, {\n      waitForEnd\n    } = {}) {\n      // In here, 'this' refers to the EventContext specific to per InteractionHandle instance spawned by each .interaction() api call.\n      // Each api call aka IH instance would therefore retain a reference to either the in-progress interaction *at the time of the call* OR a new api-started interaction.\n      this.associatedInteraction = thisClass.getInteractionFor(time);\n      if (this.associatedInteraction?.trigger === IPL_TRIGGER_NAME) this.associatedInteraction = null; // the api get-interaction method cannot target IPL\n      if (!this.associatedInteraction) {\n        // This new api-driven interaction will be the target of any subsequent .interaction() call, until it is closed by EITHER .end() OR the regular seenHistoryAndDomChange process.\n        this.associatedInteraction = thisClass.interactionInProgress = new Interaction(thisClass.agentRef, API_TRIGGER_NAME, time, thisClass.latestRouteSetByApi);\n        thisClass.domObserver.observe(document.body, {\n          attributes: true,\n          childList: true,\n          subtree: true,\n          characterData: true\n        }); // start observing for DOM changes like a regular UI-driven interaction\n        thisClass.setClosureHandlers();\n      }\n      if (waitForEnd === true) this.associatedInteraction.keepOpenUntilEndApi = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'end', function (timeNow) {\n      this.associatedInteraction.done(timeNow);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'save', function () {\n      this.associatedInteraction.forceSave = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'ignore', function () {\n      this.associatedInteraction.forceIgnore = true;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'getContext', function (time, callback) {\n      if (typeof callback !== 'function') return;\n      setTimeout(() => callback(this.associatedInteraction.customDataByApi), 0);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'onEnd', function (time, callback) {\n      if (typeof callback !== 'function') return;\n      this.associatedInteraction.onDone.push(callback);\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'actionText', function (time, newActionText) {\n      if (newActionText) this.associatedInteraction.customAttributes.actionText = newActionText;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'setName', function (time, name, trigger) {\n      if (name) this.associatedInteraction.customName = name;\n      if (trigger) this.associatedInteraction.trigger = trigger;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'setAttribute', function (time, key, value) {\n      this.associatedInteraction.customAttributes[key] = value;\n    }, thisClass.featureName, thisClass.ee);\n    registerHandler(INTERACTION_API + 'routeName', function (time, newRouteName) {\n      // notice that this fn tampers with the ixn IP, not with the linked ixn\n      thisClass.latestRouteSetByApi = newRouteName;\n      if (thisClass.interactionInProgress) thisClass.interactionInProgress.newRoute = newRouteName;\n    }, thisClass.featureName, thisClass.ee);\n  }\n}\nfunction getActionText(elem) {\n  const tagName = elem.tagName.toLowerCase();\n  const elementsOfInterest = ['a', 'button', 'input'];\n  if (elementsOfInterest.includes(tagName)) {\n    return elem.title || elem.value || elem.innerText;\n  }\n}"],"names":["nodesSeen","BelNode","agentRef","child","AjaxNode","ajaxEvent","NODE_TYPE","parentStartTimestamp","addString","getAddStringContext","nodeList","fields","numeric","nullable","allAttachedNodes","addCustomAttributes","node","Interaction","generateUuid","initialLocation","INTERACTION_STATUS","uiEvent","uiEventTimestamp","currentRouteKnown","currentUrl","API_TRIGGER_NAME","globalScope","timestamp","now","newUrl","event","cb","customEndTime","apiProvidedCb","#cancel","#finish","fn","firstStartTimeOfPayload","isFirstIxnOfPayload","ixnType","IPL_TRIGGER_NAME","INTERACTION_TYPE","cleanURL","InitialPageLoadInteraction","firstPaint","firstContentfulPaint","navTimingValues","seperator","navTimingNode","prev","v","Aggregate","AggregateBase","FEATURE_NAME","domObserver","ixn","timeToFirstByte","attrs","loadEventTime","spaOn","registerHandler","url","#registerApiHandlers","#handleAjaxEvent","#handleJserror","eventBuffer","firstIxnStartTime","serializedIxnList","interaction","eventName","startedAt","sourceElem","oldURL","INTERACTION_TRIGGERS","sourceElemText","getActionText","ref","saveIxn","interactionsBuffer","idx","finishedInteraction","associatedInteraction","processAjax","handle","FEATURE_NAMES","agent","parentInteraction","newNode","params","single","INTERACTION_API","thisClass","time","waitForEnd","timeNow","callback","newActionText","name","trigger","key","value","newRouteName","elem","tagName"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}