{"version":3,"file":"index-DnJ7TvAi.js","sources":["../../node_modules/@newrelic/browser-agent/dist/esm/common/dom/selector-path.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/user-actions/aggregated-user-action.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/user-actions/user-actions-aggregator.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/generic_events/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Generates a CSS selector path for the given element, if possible\n * @param {HTMLElement} elem\n * @param {boolean} includeId\n * @param {boolean} includeClass\n * @returns {string|undefined}\n */\nexport const generateSelectorPath = (elem, targetFields = []) => {\n  if (!elem) return {\n    path: undefined,\n    nearestFields: {}\n  };\n  const getNthOfTypeIndex = node => {\n    try {\n      let i = 1;\n      const {\n        tagName\n      } = node;\n      while (node.previousElementSibling) {\n        if (node.previousElementSibling.tagName === tagName) i++;\n        node = node.previousElementSibling;\n      }\n      return i;\n    } catch (err) {\n      // do nothing for now.  An invalid child count will make the path selector not return a nth-of-type selector statement\n    }\n  };\n  let pathSelector = '';\n  let index = getNthOfTypeIndex(elem);\n  const nearestFields = {};\n  try {\n    while (elem?.tagName) {\n      const {\n        id,\n        localName\n      } = elem;\n      targetFields.forEach(field => {\n        nearestFields[nearestAttrName(field)] ||= elem[field]?.baseVal || elem[field];\n      });\n      const selector = [localName, id ? \"#\".concat(id) : '', pathSelector ? \">\".concat(pathSelector) : ''].join('');\n      pathSelector = selector;\n      elem = elem.parentNode;\n    }\n  } catch (err) {\n    // do nothing for now\n  }\n  const path = pathSelector ? index ? \"\".concat(pathSelector, \":nth-of-type(\").concat(index, \")\") : pathSelector : undefined;\n  return {\n    path,\n    nearestFields\n  };\n  function nearestAttrName(originalFieldName) {\n    /** preserve original renaming structure for pre-existing field maps */\n    if (originalFieldName === 'tagName') originalFieldName = 'tag';\n    if (originalFieldName === 'className') originalFieldName = 'class';\n    return \"nearest\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n  }\n};","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { RAGE_CLICK_THRESHOLD_EVENTS, RAGE_CLICK_THRESHOLD_MS } from '../../constants';\nimport { cleanURL } from '../../../../common/url/clean-url';\nexport class AggregatedUserAction {\n  constructor(evt, selectorPath, nearestTargetFields) {\n    this.event = evt;\n    this.count = 1;\n    this.originMs = Math.floor(evt.timeStamp);\n    this.relativeMs = [0];\n    this.selectorPath = selectorPath;\n    this.rageClick = undefined;\n    this.nearestTargetFields = nearestTargetFields;\n    this.currentUrl = cleanURL('' + location);\n  }\n\n  /**\n   * Aggregates the count and maintains the relative MS array for matching events\n   * Will determine if a rage click was observed as part of the aggregation\n   * @param {Event} evt\n   * @returns {void}\n   */\n  aggregate(evt) {\n    this.count++;\n    this.relativeMs.push(Math.floor(evt.timeStamp - this.originMs));\n    if (this.isRageClick()) this.rageClick = true;\n  }\n\n  /**\n   * Determines if the current set of relative ms values constitutes a rage click\n   * @returns {boolean}\n   */\n  isRageClick() {\n    const len = this.relativeMs.length;\n    return this.event.type === 'click' && len >= RAGE_CLICK_THRESHOLD_EVENTS && this.relativeMs[len - 1] - this.relativeMs[len - RAGE_CLICK_THRESHOLD_EVENTS] < RAGE_CLICK_THRESHOLD_MS;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { generateSelectorPath } from '../../../../common/dom/selector-path';\nimport { OBSERVED_WINDOW_EVENTS } from '../../constants';\nimport { AggregatedUserAction } from './aggregated-user-action';\nexport class UserActionsAggregator {\n  /** @type {AggregatedUserAction=} */\n  #aggregationEvent = undefined;\n  #aggregationKey = '';\n  get aggregationEvent() {\n    // if this is accessed externally, we need to be done aggregating on it\n    // to prevent potential mutability and duplication issues, so the state is cleared upon returning.\n    // This value may need to be accessed during an unload harvest.\n    const finishedEvent = this.#aggregationEvent;\n    this.#aggregationKey = '';\n    this.#aggregationEvent = undefined;\n    return finishedEvent;\n  }\n\n  /**\n   * Process the event and determine if a new aggregation set should be made or if it should increment the current aggregation\n   * @param {Event} evt The event supplied by the addEventListener callback\n   * @returns {AggregatedUserAction|undefined} The previous aggregation set if it has been completed by processing the current event\n   */\n  process(evt, targetFields) {\n    if (!evt) return;\n    const {\n      selectorPath,\n      nearestTargetFields\n    } = getSelectorPath(evt, targetFields);\n    const aggregationKey = getAggregationKey(evt, selectorPath);\n    if (!!aggregationKey && aggregationKey === this.#aggregationKey) {\n      // an aggregation exists already, so lets just continue to increment\n      this.#aggregationEvent.aggregate(evt);\n    } else {\n      // return the prev existing one (if there is one)\n      const finishedEvent = this.#aggregationEvent;\n      // then set as this new event aggregation\n      this.#aggregationKey = aggregationKey;\n      this.#aggregationEvent = new AggregatedUserAction(evt, selectorPath, nearestTargetFields);\n      return finishedEvent;\n    }\n  }\n}\n\n/**\n * Generates a selector path for the event, starting with simple cases like window or document and getting more complex for dom-tree traversals as needed.\n * Will return a random selector path value if no other path can be determined, to force the aggregator to skip aggregation for this event.\n * @param {Event} evt\n * @returns {string}\n */\nfunction getSelectorPath(evt, targetFields) {\n  let selectorPath;\n  let nearestTargetFields = {};\n  if (OBSERVED_WINDOW_EVENTS.includes(evt.type) || evt.target === window) selectorPath = 'window';else if (evt.target === document) selectorPath = 'document';\n  // if still no selectorPath, generate one from target tree that includes elem ids\n  else {\n    const {\n      path,\n      nearestFields\n    } = generateSelectorPath(evt.target, targetFields);\n    selectorPath = path;\n    nearestTargetFields = nearestFields;\n  }\n  // if STILL no selectorPath, it will return undefined which will skip aggregation for this event\n  return {\n    selectorPath,\n    nearestTargetFields\n  };\n}\n\n/**\n * Returns an aggregation key based on the event type and the selector path of the event's target.\n * Scrollend events are aggregated into one set, no matter what.\n * @param {Event} evt\n * @param {string} selectorPath\n * @returns {string}\n */\nfunction getAggregationKey(evt, selectorPath) {\n  let aggregationKey = evt.type;\n  /** aggregate all scrollends into one set (if sequential), no matter what their target is\n   * the aggregation group's selector path with be reflected as the first one observed\n   * due to the way the aggregation logic works (by storing the initial value and aggregating it) */\n  if (evt.type !== 'scrollend') aggregationKey += '-' + selectorPath;\n  return aggregationKey;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { stringify } from '../../../common/util/stringify';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { FEATURE_NAME, RESERVED_EVENT_TYPES } from '../constants';\nimport { globalScope, initialLocation, isBrowserScope } from '../../../common/constants/runtime';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { warn } from '../../../common/util/console';\nimport { now } from '../../../common/timing/now';\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { SUPPORTABILITY_METRIC_CHANNEL } from '../../metrics/constants';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { UserActionsAggregator } from './user-actions/user-actions-aggregator';\nimport { isIFrameWindow } from '../../../common/dom/iframe';\nimport { isPureObject } from '../../../common/util/type-check';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.eventsPerHarvest = 1000;\n    this.referrerUrl = isBrowserScope && document.referrer ? cleanURL(document.referrer) : undefined;\n    this.waitForFlags(['ins']).then(([ins]) => {\n      if (!ins) {\n        this.blocked = true;\n        this.deregisterDrain();\n        return;\n      }\n      this.trackSupportabilityMetrics();\n      registerHandler('api-recordCustomEvent', (timestamp, eventType, attributes) => {\n        if (RESERVED_EVENT_TYPES.includes(eventType)) return warn(46);\n        this.addEvent({\n          eventType,\n          timestamp: this.toEpoch(timestamp),\n          ...attributes\n        });\n      }, this.featureName, this.ee);\n      if (agentRef.init.page_action.enabled) {\n        registerHandler('api-addPageAction', (timestamp, name, attributes, targetEntityGuid) => {\n          if (!this.agentRef.runtime.entityManager.get(targetEntityGuid)) return warn(56, this.featureName);\n          this.addEvent({\n            ...attributes,\n            eventType: 'PageAction',\n            timestamp: this.toEpoch(timestamp),\n            timeSinceLoad: timestamp / 1000,\n            actionName: name,\n            referrerUrl: this.referrerUrl,\n            ...(isBrowserScope && {\n              browserWidth: window.document.documentElement?.clientWidth,\n              browserHeight: window.document.documentElement?.clientHeight\n            })\n          }, targetEntityGuid);\n        }, this.featureName, this.ee);\n      }\n      let addUserAction = () => {/** no-op */};\n      if (isBrowserScope && agentRef.init.user_actions.enabled) {\n        this.userActionAggregator = new UserActionsAggregator();\n        this.harvestOpts.beforeUnload = () => addUserAction?.(this.userActionAggregator.aggregationEvent);\n        addUserAction = aggregatedUserAction => {\n          try {\n            /** The aggregator process only returns an event when it is \"done\" aggregating -\n             * so we still need to validate that an event was given to this method before we try to add */\n            if (aggregatedUserAction?.event) {\n              const {\n                target,\n                timeStamp,\n                type\n              } = aggregatedUserAction.event;\n              this.addEvent({\n                eventType: 'UserAction',\n                timestamp: this.toEpoch(timeStamp),\n                action: type,\n                actionCount: aggregatedUserAction.count,\n                actionDuration: aggregatedUserAction.relativeMs[aggregatedUserAction.relativeMs.length - 1],\n                actionMs: aggregatedUserAction.relativeMs,\n                rageClick: aggregatedUserAction.rageClick,\n                target: aggregatedUserAction.selectorPath,\n                currentUrl: aggregatedUserAction.currentUrl,\n                ...(isIFrameWindow(window) && {\n                  iframe: true\n                }),\n                ...this.agentRef.init.user_actions.elementAttributes.reduce((acc, field) => {\n                  /** prevent us from capturing an obscenely long value */\n                  if (canTrustTargetAttribute(field)) acc[targetAttrName(field)] = String(target[field]).trim().slice(0, 128);\n                  return acc;\n                }, {}),\n                ...aggregatedUserAction.nearestTargetFields\n              });\n\n              /**\n               * Returns the original target field name with `target` prepended and camelCased\n               * @param {string} originalFieldName\n               * @returns {string} the target field name\n               */\n              function targetAttrName(originalFieldName) {\n                /** preserve original renaming structure for pre-existing field maps */\n                if (originalFieldName === 'tagName') originalFieldName = 'tag';\n                if (originalFieldName === 'className') originalFieldName = 'class';\n                /** return the original field name, cap'd and prepended with target to match formatting */\n                return \"target\".concat(originalFieldName.charAt(0).toUpperCase() + originalFieldName.slice(1));\n              }\n\n              /**\n               * Only trust attributes that exist on HTML element targets, which excludes the window and the document targets\n               * @param {string} attribute The attribute to check for on the target element\n               * @returns {boolean} Whether the target element has the attribute and can be trusted\n               */\n              function canTrustTargetAttribute(attribute) {\n                return !!(aggregatedUserAction.selectorPath !== 'window' && aggregatedUserAction.selectorPath !== 'document' && target instanceof HTMLElement && target?.[attribute]);\n              }\n            }\n          } catch (e) {\n            // do nothing for now\n          }\n        };\n        registerHandler('ua', evt => {\n          /** the processor will return the previously aggregated event if it has been completed by processing the current event */\n          addUserAction(this.userActionAggregator.process(evt, this.agentRef.init.user_actions.elementAttributes));\n        }, this.featureName, this.ee);\n      }\n\n      /**\n       * is it worth complicating the agent and skipping the POs for single repeating queries? maybe,\n       * but right now it was less desirable simply because it is a nice benefit of populating the event buffer\n       * immediately as events happen for payload evaluation purposes and that becomes a little more chaotic\n       * with an arbitrary query method. note: eventTypes: [...types] does not support the 'buffered' flag so we have\n       * to create up to two PO's here.\n       */\n      const performanceTypesToCapture = [...(agentRef.init.performance.capture_marks ? ['mark'] : []), ...(agentRef.init.performance.capture_measures ? ['measure'] : [])];\n      if (performanceTypesToCapture.length) {\n        try {\n          performanceTypesToCapture.forEach(type => {\n            if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n              const observer = new PerformanceObserver(list => {\n                list.getEntries().forEach(entry => {\n                  try {\n                    this.reportSupportabilityMetric('Generic/Performance/' + type + '/Seen');\n                    const detailObj = agentRef.init.performance.capture_detail ? createDetailAttrs(entry.detail) : {};\n                    this.addEvent({\n                      ...detailObj,\n                      eventType: 'BrowserPerformance',\n                      timestamp: this.toEpoch(entry.startTime),\n                      entryName: entry.name,\n                      entryDuration: entry.duration,\n                      entryType: type\n                    });\n                    function createDetailAttrs(detail) {\n                      if (detail === null || detail === undefined) return {};else if (!isPureObject(detail)) return {\n                        entryDetail: detail\n                      };else return flattenJSON(detail);\n                      function flattenJSON(nestedJSON, parentKey = 'entryDetail') {\n                        let items = {};\n                        if (nestedJSON === null || nestedJSON === undefined) return items;\n                        Object.keys(nestedJSON).forEach(key => {\n                          let newKey = parentKey + '.' + key;\n                          if (isPureObject(nestedJSON[key])) {\n                            Object.assign(items, flattenJSON(nestedJSON[key], newKey));\n                          } else {\n                            if (nestedJSON[key] !== null && nestedJSON[key] !== undefined) items[newKey] = nestedJSON[key];\n                          }\n                        });\n                        return items;\n                      }\n                    }\n                  } catch (err) {}\n                });\n              });\n              observer.observe({\n                buffered: true,\n                type\n              });\n            }\n          });\n        } catch (err) {\n          // Something failed in our set up, likely the browser does not support PO's... do nothing\n        }\n      }\n      if (isBrowserScope && agentRef.init.performance.resources.enabled) {\n        registerHandler('browserPerformance.resource', entry => {\n          try {\n            // convert the entry to a plain object and separate the name and duration from the object\n            // you need to do this to be able to spread it into the addEvent call later, and name and duration\n            // would be duplicative of entryName and entryDuration and are protected keys in NR1\n            const {\n              name,\n              duration,\n              ...entryObject\n            } = entry.toJSON();\n            let firstParty = false;\n            try {\n              const entryDomain = new URL(name).hostname;\n              const isNr = entryDomain.includes('newrelic.com') || entryDomain.includes('nr-data.net') || entryDomain.includes('nr-local.net');\n              /** decide if we should ignore nr-specific assets */\n              if (this.agentRef.init.performance.resources.ignore_newrelic && isNr) return;\n              /** decide if we should ignore the asset type (empty means allow everything, which is the default) */\n              if (this.agentRef.init.performance.resources.asset_types.length && !this.agentRef.init.performance.resources.asset_types.includes(entryObject.initiatorType)) return;\n              /** decide if the entryDomain is a first party domain */\n              firstParty = entryDomain === globalScope?.location.hostname || agentRef.init.performance.resources.first_party_domains.includes(entryDomain);\n              if (firstParty) this.reportSupportabilityMetric('Generic/Performance/FirstPartyResource/Seen');\n              if (isNr) this.reportSupportabilityMetric('Generic/Performance/NrResource/Seen');\n            } catch (err) {\n              // couldnt parse the URL, so firstParty will just default to false\n            }\n            this.reportSupportabilityMetric('Generic/Performance/Resource/Seen');\n            const event = {\n              ...entryObject,\n              eventType: 'BrowserPerformance',\n              timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(entryObject.startTime)),\n              entryName: cleanURL(name),\n              entryDuration: duration,\n              firstParty\n            };\n            this.addEvent(event);\n          } catch (err) {\n            this.ee.emit('internal-error', [err, 'GenericEvents-Resource']);\n          }\n        }, this.featureName, this.ee);\n      }\n      registerHandler('api-measure', (args, n) => {\n        const {\n          start,\n          duration,\n          customAttributes\n        } = args;\n        const event = {\n          ...customAttributes,\n          eventType: 'BrowserPerformance',\n          timestamp: Math.floor(agentRef.runtime.timeKeeper.correctRelativeTimestamp(start)),\n          entryName: n,\n          entryDuration: duration,\n          entryType: 'measure'\n        };\n        this.addEvent(event);\n      }, this.featureName, this.ee);\n      agentRef.runtime.harvester.triggerHarvestFor(this);\n      this.drain();\n    });\n  }\n\n  // WARNING: Insights times are in seconds. EXCEPT timestamp, which is in ms.\n  /** Some keys are set by the query params or request headers sent with the harvest and override the body values, so check those before adding new standard body values...\n   * see harvest.js#baseQueryString for more info on the query params\n   * Notably:\n   * * name: set by the `t=` query param\n   * * appId: set by the `a=` query param\n   * * standalone: set by the `sa=` query param\n   * * session: set by the `s=` query param\n   * * sessionTraceId: set by the `ptid=` query param\n   * * userAgent*: set by the userAgent header\n   * @param {object=} obj the event object for storing in the event buffer\n   * @param {string=} targetEntityGuid the target entity guid for the event to scope buffering and harvesting. Defaults to agent config if undefined\n   * @returns void\n   */\n  addEvent(obj = {}, targetEntityGuid) {\n    if (!obj || !Object.keys(obj).length) return;\n    if (!obj.eventType) {\n      warn(44);\n      return;\n    }\n    for (let key in obj) {\n      let val = obj[key];\n      obj[key] = val && typeof val === 'object' ? stringify(val) : val;\n    }\n    const defaultEventAttributes = {\n      /** should be overridden by the event-specific attributes, but just in case -- set it to now() */\n      timestamp: Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(now())),\n      /** all generic events require pageUrl(s) */\n      pageUrl: cleanURL('' + initialLocation),\n      currentUrl: cleanURL('' + location)\n    };\n    const eventAttributes = {\n      /** Agent-level custom attributes */\n      ...(this.agentRef.info.jsAttributes || {}),\n      /** Fallbacks for required properties in-case the event did not supply them, should take precedence over agent-level custom attrs */\n      ...defaultEventAttributes,\n      /** Event-specific attributes take precedence over agent-level custom attributes and fallbacks */\n      ...obj\n    };\n    const addedEvent = this.events.add(eventAttributes, targetEntityGuid);\n    if (!addedEvent && !this.events.isEmpty(undefined, targetEntityGuid)) {\n      /** could not add the event because it pushed the buffer over the limit\n       * so we harvest early, and try to add it again now that the buffer is cleared\n       * if it fails again, we do nothing\n       */\n      this.ee.emit(SUPPORTABILITY_METRIC_CHANNEL, ['GenericEvents/Harvest/Max/Seen']);\n      this.agentRef.runtime.harvester.triggerHarvestFor(this, {\n        targetEntityGuid\n      });\n      this.events.add(eventAttributes);\n    }\n  }\n  serializer(eventBuffer) {\n    return applyFnToProps({\n      ins: eventBuffer\n    }, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n  }\n  queryStringsBuilder() {\n    return {\n      ua: this.agentRef.info.userAttributes,\n      at: this.agentRef.info.atts\n    };\n  }\n  toEpoch(timestamp) {\n    return Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(timestamp));\n  }\n  trackSupportabilityMetrics() {\n    /** track usage SMs to improve these experimental features */\n    const configPerfTag = 'Config/Performance/';\n    if (this.agentRef.init.performance.capture_marks) this.reportSupportabilityMetric(configPerfTag + 'CaptureMarks/Enabled');\n    if (this.agentRef.init.performance.capture_measures) this.reportSupportabilityMetric(configPerfTag + 'CaptureMeasures/Enabled');\n    if (this.agentRef.init.performance.resources.enabled) this.reportSupportabilityMetric(configPerfTag + 'Resources/Enabled');\n    if (this.agentRef.init.performance.resources.asset_types?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/AssetTypes/Changed');\n    if (this.agentRef.init.performance.resources.first_party_domains?.length !== 0) this.reportSupportabilityMetric(configPerfTag + 'Resources/FirstPartyDomains/Changed');\n    if (this.agentRef.init.performance.resources.ignore_newrelic === false) this.reportSupportabilityMetric(configPerfTag + 'Resources/IgnoreNewrelic/Changed');\n  }\n}"],"names":["generateSelectorPath","elem","targetFields","getNthOfTypeIndex","node","i","tagName","pathSelector","index","nearestFields","id","localName","field","nearestAttrName","originalFieldName","AggregatedUserAction","evt","selectorPath","nearestTargetFields","cleanURL","len","RAGE_CLICK_THRESHOLD_EVENTS","RAGE_CLICK_THRESHOLD_MS","UserActionsAggregator","#aggregationEvent","#aggregationKey","finishedEvent","getSelectorPath","aggregationKey","getAggregationKey","OBSERVED_WINDOW_EVENTS","path","Aggregate","AggregateBase","FEATURE_NAME","agentRef","isBrowserScope","ins","registerHandler","timestamp","eventType","attributes","RESERVED_EVENT_TYPES","warn","name","targetEntityGuid","addUserAction","aggregatedUserAction","targetAttrName","canTrustTargetAttribute","attribute","target","timeStamp","type","isIFrameWindow","acc","performanceTypesToCapture","list","entry","createDetailAttrs","detail","isPureObject","flattenJSON","nestedJSON","parentKey","items","key","newKey","detailObj","duration","entryObject","firstParty","entryDomain","isNr","globalScope","event","err","args","n","start","customAttributes","obj","val","stringify","defaultEventAttributes","now","initialLocation","eventAttributes","SUPPORTABILITY_METRIC_CHANNEL","eventBuffer","applyFnToProps","configPerfTag"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}