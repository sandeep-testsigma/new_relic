{"version":3,"mappings":"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","names":["onReplayReady","sessionReplayInitialized","resolve","sharedChannel","Aggregate","AggregateBase","FEATURE_NAME","MODE","agentRef","args","canEnableSessionTracking","SESSION_EVENTS","ABORT_REASONS","type","data","SESSION_EVENT_TYPES","registerHandler","SR_EVENT_EMITTER_TYPES","e","error_sampling_rate","sampling_rate","autoStart","block_selector","mask_text_selector","mask_all_inputs","inline_images","collect_fonts","srMode","entitled","globalScope","ignoreSession","session","timeKeeper","TRIGGERS","Recorder","__vitePreload","gzipSync","strToU8","shouldRetryOnFail","payloadOutput","recorderEvents","payload","len","__serialized","output","buildNRMetaNode","stringify","node","MAX_PAYLOAD_SIZE","warn","events","agentRuntime","endUserId","RRWEB_EVENT_TYPES","x","relativeNow","now","firstEventTimestamp","lastEventTimestamp","firstTimestamp","lastTimestamp","agentMetadata","encodeObj","stylesheetEvaluator","RRWEB_VERSION","cleanURL","QUERY_PARAM_PADDING","result","forceHarvest","reason","state"],"ignoreList":[0,1],"sources":["../../node_modules/@newrelic/browser-agent/dist/esm/common/constants/shared-channel.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/session_replay/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @file Keeps an object alive that is passed to all feature aggregate modules.\n * The purpose is to have a way for communication and signals to relay across features at runtime.\n * This object can hold any arbitrary values and should be treated as on-the-fly dynamic.\n */\n\nlet onReplayReady;\nconst sessionReplayInitialized = new Promise(resolve => {\n  onReplayReady = resolve;\n});\nexport const sharedChannel = Object.freeze({\n  onReplayReady,\n  sessionReplayInitialized\n});","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @file Records, aggregates, and harvests session replay data.\n */\n\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { ABORT_REASONS, FEATURE_NAME, QUERY_PARAM_PADDING, RRWEB_EVENT_TYPES, SR_EVENT_EMITTER_TYPES, TRIGGERS } from '../constants';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { sharedChannel } from '../../../common/constants/shared-channel';\nimport { obj as encodeObj } from '../../../common/url/encode';\nimport { warn } from '../../../common/util/console';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { RRWEB_VERSION } from \"../../../common/constants/env.npm\";\nimport { MODE, SESSION_EVENTS, SESSION_EVENT_TYPES } from '../../../common/session/constants';\nimport { stringify } from '../../../common/util/stringify';\nimport { stylesheetEvaluator } from '../shared/stylesheet-evaluator';\nimport { now } from '../../../common/timing/now';\nimport { buildNRMetaNode } from '../shared/utils';\nimport { MAX_PAYLOAD_SIZE } from '../../../common/constants/agent-constants';\nimport { cleanURL } from '../../../common/url/clean-url';\nimport { canEnableSessionTracking } from '../../utils/feature-gates';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  mode = MODE.OFF;\n\n  // pass the recorder into the aggregator\n  constructor(agentRef, args) {\n    super(agentRef, FEATURE_NAME);\n    /** Set once the recorder has fully initialized after flag checks and sampling */\n    this.initialized = false;\n    /** Set once the feature has been \"aborted\" to prevent other side-effects from continuing */\n    this.blocked = false;\n    /** populated with the gzipper lib async */\n    this.gzipper = undefined;\n    /** populated with the u8 string lib async */\n    this.u8 = undefined;\n\n    /** set by BCS response */\n    this.entitled = false;\n    /** set at BCS response, stored in runtime */\n    this.timeKeeper = undefined;\n    this.recorder = args?.recorder;\n    this.errorNoticed = args?.errorNoticed || false;\n    this.harvestOpts.raw = true;\n    this.isSessionTrackingEnabled = canEnableSessionTracking(agentRef.init) && !!agentRef.runtime.session;\n    this.reportSupportabilityMetric('Config/SessionReplay/Enabled');\n\n    // The SessionEntity class can emit a message indicating the session was cleared and reset (expiry, inactivity). This feature must abort and never resume if that occurs.\n    this.ee.on(SESSION_EVENTS.RESET, () => {\n      this.abort(ABORT_REASONS.RESET);\n    });\n\n    // The SessionEntity class can emit a message indicating the session was paused (visibility change). This feature must stop recording if that occurs.\n    this.ee.on(SESSION_EVENTS.PAUSE, () => {\n      this.recorder?.stopRecording();\n    });\n    // The SessionEntity class can emit a message indicating the session was resumed (visibility change). This feature must start running again (if already running) if that occurs.\n    this.ee.on(SESSION_EVENTS.RESUME, () => {\n      if (!this.recorder) return;\n      // if the mode changed on a different tab, it needs to update this instance to match\n      this.mode = agentRef.runtime.session.state.sessionReplayMode;\n      if (!this.initialized || this.mode === MODE.OFF) return;\n      this.recorder?.startRecording();\n    });\n    this.ee.on(SESSION_EVENTS.UPDATE, (type, data) => {\n      if (!this.recorder || !this.initialized || this.blocked || type !== SESSION_EVENT_TYPES.CROSS_TAB) return;\n      if (this.mode !== MODE.OFF && data.sessionReplayMode === MODE.OFF) this.abort(ABORT_REASONS.CROSS_TAB);\n      this.mode = data.sessionReplayMode;\n    });\n    registerHandler(SR_EVENT_EMITTER_TYPES.PAUSE, () => {\n      this.forceStop(this.mode === MODE.FULL);\n    }, this.featureName, this.ee);\n    registerHandler(SR_EVENT_EMITTER_TYPES.ERROR_DURING_REPLAY, e => {\n      this.handleError(e);\n    }, this.featureName, this.ee);\n    const {\n      error_sampling_rate,\n      sampling_rate,\n      autoStart,\n      block_selector,\n      mask_text_selector,\n      mask_all_inputs,\n      inline_images,\n      collect_fonts\n    } = agentRef.init.session_replay;\n    this.waitForFlags(['srs', 'sr']).then(([srMode, entitled]) => {\n      this.entitled = !!entitled;\n      if (!this.entitled) {\n        this.deregisterDrain();\n        if (this.agentRef.runtime.isRecording) {\n          this.abort(ABORT_REASONS.ENTITLEMENTS);\n          this.reportSupportabilityMetric('SessionReplay/EnabledNotEntitled/Detected');\n        }\n        return;\n      }\n      this.drain();\n      this.initializeRecording(srMode);\n    }).then(() => {\n      if (this.mode === MODE.OFF) {\n        this.recorder?.stopRecording(); // stop any conservative preload recording launched by instrument\n        while (this.recorder?.getEvents().events.length) this.recorder?.clearBuffer?.();\n      }\n      sharedChannel.onReplayReady(this.mode);\n    }); // notify watchers that replay started with the mode\n\n    /** Detect if the default configs have been altered and report a SM.  This is useful to evaluate what the reasonable defaults are across a customer base over time */\n    if (!autoStart) this.reportSupportabilityMetric('Config/SessionReplay/AutoStart/Modified');\n    if (collect_fonts === true) this.reportSupportabilityMetric('Config/SessionReplay/CollectFonts/Modified');\n    if (inline_images === true) this.reportSupportabilityMetric('Config/SessionReplay/InlineImages/Modifed');\n    if (mask_all_inputs !== true) this.reportSupportabilityMetric('Config/SessionReplay/MaskAllInputs/Modified');\n    if (block_selector !== '[data-nr-block]') this.reportSupportabilityMetric('Config/SessionReplay/BlockSelector/Modified');\n    if (mask_text_selector !== '*') this.reportSupportabilityMetric('Config/SessionReplay/MaskTextSelector/Modified');\n    this.reportSupportabilityMetric('Config/SessionReplay/SamplingRate/Value', sampling_rate);\n    this.reportSupportabilityMetric('Config/SessionReplay/ErrorSamplingRate/Value', error_sampling_rate);\n  }\n  replayIsActive() {\n    return Boolean(this.recorder && this.mode === MODE.FULL && !this.blocked && this.entitled);\n  }\n  handleError(e) {\n    if (this.recorder) this.recorder.currentBufferTarget.hasError = true;\n    // run once\n    if (this.mode === MODE.ERROR && globalScope?.document.visibilityState === 'visible') {\n      this.switchToFull();\n    }\n  }\n  switchToFull() {\n    if (!this.entitled || this.blocked) return;\n    this.mode = MODE.FULL;\n    // if the error was noticed AFTER the recorder was already imported....\n    if (this.recorder && this.initialized) {\n      if (!this.agentRef.runtime.isRecording) this.recorder.startRecording();\n      this.syncWithSessionManager({\n        sessionReplayMode: this.mode\n      });\n    } else {\n      this.initializeRecording(MODE.FULL, true);\n    }\n  }\n\n  /**\n   * Evaluate entitlements and sampling before starting feature mechanics, importing and configuring recording library, and setting storage state\n   * @param {boolean} srMode - the true/false state of the \"sr\" flag (aka. entitlements) from RUM response\n   * @param {boolean} ignoreSession - whether to force the method to ignore the session state and use just the sample flags\n   * @returns {void}\n   */\n  async initializeRecording(srMode, ignoreSession) {\n    this.initialized = true;\n    if (!this.entitled) return;\n\n    // if theres an existing session replay in progress, there's no need to sample, just check the entitlements response\n    // if not, these sample flags need to be checked\n    // if this isnt the FIRST load of a session AND\n    // we are not actively recording SR... DO NOT import or run the recording library\n    // session replay samples can only be decided on the first load of a session\n    // session replays can continue if already in progress\n    const {\n      session,\n      timeKeeper\n    } = this.agentRef.runtime;\n    this.timeKeeper = timeKeeper;\n    if (this.recorder?.parent.trigger === TRIGGERS.API && this.agentRef.runtime.isRecording) {\n      this.mode = MODE.FULL;\n    } else if (!session.isNew && !ignoreSession) {\n      // inherit the mode of the existing session\n      this.mode = session.state.sessionReplayMode;\n    } else {\n      // The session is new... determine the mode the new session should start in\n      this.mode = srMode;\n    }\n    // If off, then don't record (early return)\n    if (this.mode === MODE.OFF) return;\n    if (!this.recorder) {\n      try {\n        // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n        const {\n          Recorder\n        } = await import(/* webpackChunkName: \"recorder\" */'../shared/recorder');\n        this.recorder = new Recorder(this);\n        this.recorder.currentBufferTarget.hasError = this.errorNoticed;\n      } catch (err) {\n        return this.abort(ABORT_REASONS.IMPORT);\n      }\n    } else {\n      this.recorder.parent = this;\n    }\n\n    // If an error was noticed before the mode could be set (like in the early lifecycle of the page), immediately set to FULL mode\n    if (this.mode === MODE.ERROR && this.errorNoticed) this.mode = MODE.FULL;\n\n    // FULL mode records AND reports from the beginning, while ERROR mode only records (but does not report).\n    // ERROR mode will do this until an error is thrown, and then switch into FULL mode.\n    // The makeHarvestPayload should ensure that no payload is returned if we're not in FULL mode...\n\n    // If theres preloaded events and we are in full mode, just harvest immediately to clear up space and for consistency\n    if (this.mode === MODE.FULL && this.recorder?.getEvents().type === 'preloaded') {\n      this.prepUtils().then(() => this.agentRef.runtime.harvester.triggerHarvestFor(this));\n    }\n    await this.prepUtils();\n    if (!this.agentRef.runtime.isRecording) this.recorder.startRecording();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n  async prepUtils() {\n    try {\n      // Do not change the webpackChunkName or it will break the webpack nrba-chunking plugin\n      const {\n        gzipSync,\n        strToU8\n      } = await import(/* webpackChunkName: \"compressor\" */'fflate');\n      this.gzipper = gzipSync;\n      this.u8 = strToU8;\n    } catch (err) {\n      // compressor failed to load, but we can still record without compression as a last ditch effort\n    }\n  }\n  makeHarvestPayload(shouldRetryOnFail) {\n    const payloadOutput = {\n      targetApp: undefined,\n      payload: undefined\n    };\n    if (this.mode !== MODE.FULL || this.blocked) return;\n    if (!this.recorder || !this.timeKeeper?.ready || !this.recorder.hasSeenSnapshot) return;\n    const recorderEvents = this.recorder.getEvents();\n    // get the event type and use that to trigger another harvest if needed\n    if (!recorderEvents.events.length) return;\n    const payload = this.getHarvestContents(recorderEvents);\n    if (!payload.body.length) {\n      this.recorder.clearBuffer();\n      return [payloadOutput];\n    }\n    this.reportSupportabilityMetric('SessionReplay/Harvest/Attempts');\n    let len = 0;\n    if (!!this.gzipper && !!this.u8) {\n      payload.body = this.gzipper(this.u8(\"[\".concat(payload.body.map(({\n        __serialized,\n        ...e\n      }) => {\n        if (e.__newrelic && __serialized) return __serialized;\n        const output = {\n          ...e\n        };\n        if (!output.__newrelic) {\n          output.__newrelic = buildNRMetaNode(e.timestamp, this.timeKeeper);\n          output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(e.timestamp);\n        }\n        return stringify(output);\n      }).join(','), \"]\")));\n      len = payload.body.length;\n    } else {\n      payload.body = payload.body.map(({\n        __serialized,\n        ...node\n      }) => {\n        if (node.__newrelic) return node;\n        const output = {\n          ...node\n        };\n        output.__newrelic = buildNRMetaNode(node.timestamp, this.timeKeeper);\n        output.timestamp = this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n        return output;\n      });\n      len = stringify(payload.body).length;\n    }\n    if (len > MAX_PAYLOAD_SIZE) {\n      this.abort(ABORT_REASONS.TOO_BIG, len);\n      return [payloadOutput];\n    }\n    // TODO -- Gracefully handle the buffer for retries.\n    if (!this.agentRef.runtime.session.state.sessionReplaySentFirstChunk) this.syncWithSessionManager({\n      sessionReplaySentFirstChunk: true\n    });\n    this.recorder.clearBuffer();\n    if (recorderEvents.type === 'preloaded') this.agentRef.runtime.harvester.triggerHarvestFor(this);\n    payloadOutput.payload = payload;\n    if (!this.agentRef.runtime.session.state.traceHarvestStarted) {\n      warn(59, JSON.stringify(this.agentRef.runtime.session.state));\n    }\n    return [payloadOutput];\n  }\n  getCorrectedTimestamp(node) {\n    if (!node?.timestamp) return;\n    if (node.__newrelic) return node.timestamp;\n    return this.timeKeeper.correctAbsoluteTimestamp(node.timestamp);\n  }\n  getHarvestContents(recorderEvents) {\n    recorderEvents ??= this.recorder.getEvents();\n    let events = recorderEvents.events;\n    const agentRuntime = this.agentRef.runtime;\n    const endUserId = this.agentRef.info.jsAttributes?.['enduser.id'];\n\n    // do not let the first node be a full snapshot node, since this NEEDS to be preceded by a meta node\n    // we will manually inject it if this happens\n    const payloadStartsWithFullSnapshot = events?.[0]?.type === RRWEB_EVENT_TYPES.FullSnapshot;\n    if (payloadStartsWithFullSnapshot && !!this.recorder.lastMeta) {\n      recorderEvents.hasMeta = true;\n      events.unshift(this.recorder.lastMeta); // --> pushed the meta from a previous payload into newer payload... but it still has old timestamps\n      this.recorder.lastMeta = undefined;\n    }\n\n    // do not let the last node be a meta node, since this NEEDS to precede a snapshot\n    // we will manually inject it later if we find a payload that is missing a meta node\n    const payloadEndsWithMeta = events[events.length - 1]?.type === RRWEB_EVENT_TYPES.Meta;\n    if (payloadEndsWithMeta) {\n      this.recorder.lastMeta = events[events.length - 1];\n      events = events.slice(0, events.length - 1);\n      recorderEvents.hasMeta = !!events.find(x => x.type === RRWEB_EVENT_TYPES.Meta);\n    }\n    const relativeNow = now();\n    const firstEventTimestamp = this.getCorrectedTimestamp(events[0]); // from rrweb node\n    const lastEventTimestamp = this.getCorrectedTimestamp(events[events.length - 1]); // from rrweb node\n    // from rrweb node || from when the harvest cycle started\n    const firstTimestamp = firstEventTimestamp || Math.floor(this.timeKeeper.correctAbsoluteTimestamp(recorderEvents.cycleTimestamp));\n    const lastTimestamp = lastEventTimestamp || Math.floor(this.timeKeeper.correctRelativeTimestamp(relativeNow));\n    const agentMetadata = agentRuntime.appMetadata?.agents?.[0] || {};\n    return {\n      qs: {\n        browser_monitoring_key: this.agentRef.info.licenseKey,\n        type: 'SessionReplay',\n        app_id: this.agentRef.info.applicationID,\n        protocol_version: '0',\n        timestamp: firstTimestamp,\n        attributes: encodeObj({\n          // this section of attributes must be controllable and stay below the query param padding limit -- see QUERY_PARAM_PADDING\n          // if not, data could be lost to truncation at time of sending, potentially breaking parsing / API behavior in NR1\n          ...(!!this.gzipper && !!this.u8 && {\n            content_encoding: 'gzip'\n          }),\n          ...(agentMetadata.entityGuid && {\n            entityGuid: agentMetadata.entityGuid\n          }),\n          harvestId: [agentRuntime.session?.state.value, agentRuntime.ptid, agentRuntime.harvestCount].filter(x => x).join('_'),\n          'replay.firstTimestamp': firstTimestamp,\n          'replay.lastTimestamp': lastTimestamp,\n          'replay.nodes': events.length,\n          'session.durationMs': agentRuntime.session.getDuration(),\n          agentVersion: agentRuntime.version,\n          session: agentRuntime.session.state.value,\n          rst: relativeNow,\n          hasMeta: recorderEvents.hasMeta || false,\n          hasSnapshot: recorderEvents.hasSnapshot || false,\n          hasError: recorderEvents.hasError || false,\n          isFirstChunk: agentRuntime.session.state.sessionReplaySentFirstChunk === false,\n          decompressedBytes: recorderEvents.payloadBytesEstimation,\n          invalidStylesheetsDetected: stylesheetEvaluator.invalidStylesheetsDetected,\n          inlinedAllStylesheets: recorderEvents.inlinedAllStylesheets,\n          'rrweb.version': RRWEB_VERSION,\n          'payload.type': recorderEvents.type,\n          // customer-defined data should go last so that if it exceeds the query param padding limit it will be truncated instead of important attrs\n          ...(endUserId && {\n            'enduser.id': this.obfuscator.obfuscateString(endUserId)\n          }),\n          currentUrl: this.obfuscator.obfuscateString(cleanURL('' + location))\n          // The Query Param is being arbitrarily limited in length here.  It is also applied when estimating the size of the payload in getPayloadSize()\n        }, QUERY_PARAM_PADDING).substring(1) // remove the leading '&'\n      },\n      body: events\n    };\n  }\n  postHarvestCleanup(result) {\n    // The mutual decision for now is to stop recording and clear buffers if ingest is experiencing 429 rate limiting\n    if (result.status === 429) {\n      this.abort(ABORT_REASONS.TOO_MANY);\n    }\n  }\n\n  /**\n   * Forces the agent into OFF mode so that changing tabs or navigating\n   * does not restart the recording. This is used when the customer calls\n   * the stopRecording API.\n   */\n  forceStop(forceHarvest) {\n    if (forceHarvest) this.agentRef.runtime.harvester.triggerHarvestFor(this);\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n  }\n\n  /** Abort the feature, once aborted it will not resume */\n  abort(reason = {}, data) {\n    warn(33, reason.message);\n    this.reportSupportabilityMetric(\"SessionReplay/Abort/\".concat(reason.sm), data);\n    this.blocked = true;\n    this.mode = MODE.OFF;\n    this.recorder?.stopRecording?.();\n    this.syncWithSessionManager({\n      sessionReplayMode: this.mode\n    });\n    this.recorder?.clearTimestamps?.();\n    while (this.recorder?.getEvents().events.length) this.recorder?.clearBuffer?.();\n  }\n  syncWithSessionManager(state = {}) {\n    if (this.isSessionTrackingEnabled) {\n      this.agentRef.runtime.session.write(state);\n    }\n  }\n}"],"file":"assets/index-QYDvMsrd.js"}