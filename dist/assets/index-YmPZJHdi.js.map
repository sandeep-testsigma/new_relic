{"version":3,"file":"index-YmPZJHdi.js","sources":["../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/canonical-function-name.js","../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/format-stack-trace.js","../../node_modules/@newrelic/browser-agent/src/common/url/canonicalize-url.js","../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/compute-stack-trace.js","../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/string-hash-code.js","../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/internal-errors.js","../../node_modules/@newrelic/browser-agent/src/features/jserrors/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst canonicalFunctionNameRe = /([a-z0-9]+)$/i\n\n/**\n * Given a function name string, extracts only an alphanumeric segment at the end of the string (if one exists).\n * This is useful for stack traces, where functions might not be named (e.g., anonymous, computed).\n *\n * @param {string} functionNameString - The original function name string.\n * @returns {string|undefined} The canonical function name, or undefined if the input is falsy or no alphanumeric segments are found.\n */\nexport function canonicalFunctionName (functionNameString) {\n  if (!functionNameString) return\n\n  const match = functionNameString.match(canonicalFunctionNameRe)\n  if (match) return match[1]\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g\nvar MAX_STACK_TRACE_LENGTH = 65530\n\nexport function formatStackTrace (stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '')\n}\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines (stackLines) {\n  var stackString\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100\n    stackString = stackLines.slice(0, 50).join('\\n')\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n'\n    stackString += stackLines.slice(-50).join('\\n')\n  } else {\n    stackString = stackLines.join('\\n')\n  }\n  return stackString\n}\n\n// truncates stack string to limit what is sent to backend\nexport function truncateSize (stackString) {\n  return (stackString.length > MAX_STACK_TRACE_LENGTH) ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { initialLocation } from '../constants/runtime'\nimport { cleanURL } from './clean-url'\n\n/**\n * Converts a URL to its basic form without a query string or fragment. If the resulting URL is the same as the\n * loader's origin URL, returns '<inline>'.\n * @param {string} url - The URL to be canonicalized.\n * @param {string} loaderOriginUrl - The origin URL of the agent loader, used for inline detection.\n * @returns {string} The canonicalized URL, or '<inline>' if the URL matches the loader origin URL.\n */\nexport function canonicalizeUrl (url) {\n  if (typeof url !== 'string') return ''\n\n  const cleanedUrl = cleanURL(url)\n  const cleanedGlobalScopeUrl = cleanURL(initialLocation)\n\n  // If the URL matches the origin URL of the loader, we assume it originated within an inline script.\n  if (cleanedUrl === cleanedGlobalScopeUrl) {\n    return '<inline>'\n  } else {\n    return cleanedUrl\n  }\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable no-useless-escape */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\nimport { formatStackTrace } from './format-stack-trace'\nimport { canonicalizeUrl } from '../../../common/url/canonicalize-url'\n\nvar debug = false\n\nvar classNameRegex = /function (.+?)\\s*\\(/\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i\nvar chromeEval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i\nvar ieEval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i\n\n/**\n * Represents an error with a stack trace.\n * @typedef {Object} StackInfo\n * @property {string} name - The name of the error (e.g. 'TypeError').\n * @property {string} message - The error message.\n * @property {string} stackString - The stack trace as a string.\n * @property {Array<Object>} frames - An array of frames in the stack trace.\n * @property {string} frames.url - The URL of the file containing the code for the frame.\n * @property {string} frames.func - The name of the function associated with the frame.\n * @property {number} frames.line - The line number of the code in the frame.\n */\n\n/**\n * Attempts to compute a stack trace for the given exception.\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackInfo} A stack trace object containing information about the frames on the stack.\n */\nexport function computeStackTrace (ex) {\n  var stack = null\n\n  try {\n    stack = computeStackTraceFromStackProp(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceBySourceAndLine(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  try {\n    stack = computeStackTraceWithMessageOnly(ex)\n    if (stack) {\n      return stack\n    }\n  } catch (e) {\n    if (debug) {\n      throw e\n    }\n  }\n\n  return {\n    mode: 'failed',\n    stackString: '',\n    frames: []\n  }\n}\n\n/**\n * Computes stack trace information from the stack property. Chrome and Gecko use this property.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp (ex) {\n  if (!ex.stack) {\n    return null\n  }\n\n  var errorInfo = ex.stack.split('\\n').reduce(\n    parseStackProp,\n    { frames: [], stackLines: [], wrapperSeen: false }\n  )\n\n  if (!errorInfo.frames.length) return null\n\n  return {\n    mode: 'stack',\n    name: ex.name || getClassName(ex),\n    message: ex.message,\n    stackString: formatStackTrace(errorInfo.stackLines),\n    frames: errorInfo.frames\n  }\n}\n\n/**\n * Parses a line from a JavaScript error stack trace and adds it to the given `info` object.\n * Ignores all stack entries thrown from one of our wrapper functions.\n *\n * @param {object} info - The `info` object to add the parsed line to.\n * @param {string} line - The line to parse.\n * @returns {object} The `info` object with the parsed line added.\n */\nfunction parseStackProp (info, line) {\n  let element = getStackElement(line)\n\n  // This catches lines that aren't frames (like the first line stating the error).\n  if (!element) {\n    info.stackLines.push(line)\n    return info\n  }\n\n  // Once we've seen a wrapper, ignore all subsequent stack entries.\n  if (isNrWrapper(element.func)) info.wrapperSeen = true\n  if (!info.wrapperSeen) {\n    // Query strings and fragments should be removed, and URLs matching the loader's origin should be \"<inline>\".\n    let canonicalUrl = canonicalizeUrl(element.url)\n    if (canonicalUrl !== element.url) {\n      line = line.replace(element.url, canonicalUrl)\n      element.url = canonicalUrl\n    }\n\n    info.stackLines.push(line)\n    info.frames.push(element)\n  }\n\n  return info\n}\n\n/**\n * Parses a line from a JavaScript error stack trace to extract information about a stack trace element, such as the\n * URL, function name, line number, and column number.\n *\n * @param {string} line - A single line from a JavaScript error stack trace.\n * @returns {object} An object containing information about the stack trace element, including the URL, function\n *     name, line number, and column number (if available).\n */\nfunction getStackElement (line) {\n  var parts = line.match(gecko)\n  if (!parts) parts = line.match(chrome)\n\n  if (parts) {\n    return ({\n      url: parts[2],\n      func: (parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1]) || null,\n      line: +parts[3],\n      column: parts[4] ? +parts[4] : null\n    })\n  }\n\n  if (line.match(chromeEval) || line.match(ieEval) || line === 'anonymous') {\n    return { func: 'evaluated code' }\n  }\n}\n\n/**\n * Computes a stack trace object from an error object, by extracting the source and line number from the error object,\n * and using them to create a single stack frame.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @returns {Object|null} - An object representing the computed stack trace, or null if the\n * input error object does not contain a line number.\n */\nfunction computeStackTraceBySourceAndLine (ex) {\n  if (!('line' in ex)) return null\n\n  var className = ex.name || getClassName(ex)\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return ({\n      mode: 'sourceline',\n      name: className,\n      message: ex.message,\n      stackString: className + ': ' + ex.message + '\\n    in evaluated code',\n      frames: [{\n        func: 'evaluated code'\n      }]\n    })\n  }\n\n  // Remove any query string and fragment\n  var canonicalUrl = canonicalizeUrl(ex.sourceURL)\n\n  var stackString = className + ': ' + ex.message + '\\n    at ' + canonicalUrl\n  if (ex.line) {\n    stackString += ':' + ex.line\n    if (ex.column) {\n      stackString += ':' + ex.column\n    }\n  }\n\n  return ({\n    mode: 'sourceline',\n    name: className,\n    message: ex.message,\n    stackString,\n    frames: [{\n      url: canonicalUrl,\n      line: ex.line,\n      column: ex.column\n    }]\n  })\n}\n\n/**\n * For exceptions with no stack and only a message, derives a stack trace by extracting the class name and message.\n *\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackTrace} A stack trace object containing the name and message of the exception.\n */\nfunction computeStackTraceWithMessageOnly (ex) {\n  var className = ex.name || getClassName(ex)\n  if (!className) return null\n\n  return ({\n    mode: 'nameonly',\n    name: className,\n    message: ex.message,\n    stackString: className + ': ' + ex.message,\n    frames: []\n  })\n}\n\n/**\n * Attempts to extract the name of the constructor function (the class) of the given object.\n *\n * @param {Object} obj - The object for which to extract the constructor function name.\n * @returns {string} The name of the constructor function, or 'unknown' if the name cannot be determined.\n */\nfunction getClassName (obj) {\n  var results = classNameRegex.exec(String(obj.constructor))\n  return (results && results.length > 1) ? results[1] : 'unknown'\n}\n\n/**\n * Checks whether the given function name is a New Relic wrapper function.\n *\n * @param {string} functionName - The name of the function to check.\n * @returns {boolean} True if the function name includes the string 'nrWrapper', false otherwise.\n */\nfunction isNrWrapper (functionName) {\n  return (functionName && functionName.indexOf('nrWrapper') >= 0)\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport function stringHashCode (string) {\n  var hash = 0\n  var charVal\n\n  if (!string || !string.length) return hash\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i)\n    hash = ((hash << 5) - hash) + charVal\n    hash = hash | 0 // Convert to 32bit integer\n  }\n  return hash\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nconst REASON_RRWEB = 'Rrweb'\nconst REASON_SECURITY_POLICY = 'Security-Policy'\n/**\n * This function is responsible for determining if an error should be swallowed or not.\n * @param {Object} stackInfo - The error stack information.\n * @returns {boolean} - Whether the error should be swallowed or not.\n */\nexport function evaluateInternalError (stackInfo, internal, reason) {\n  const output = { shouldSwallow: internal || false, reason: reason || 'Other' }\n  const leadingFrame = stackInfo.frames?.[0]\n  /** If we cant otherwise determine from the frames and message, the default of internal + reason will be the fallback */\n  if (!leadingFrame || typeof stackInfo?.message !== 'string') return output\n\n  // check if the error happened in expected modules or if messages match known patterns\n  const isNrRecorder = leadingFrame?.url?.match(/nr-(.*)-recorder.min.js/)\n  const isRrweb = leadingFrame?.url?.match(/rrweb/)\n  const isMaybeNrRecorder = leadingFrame?.url?.match(/recorder/)\n  const isSecurityPolicyAPIError = stackInfo.message.toLowerCase().match(/an attempt was made to break through the security policy of the user agent/)\n\n  // check if modules and patterns above fit known swallow cases\n  if (!!isNrRecorder || !!isRrweb) {\n    /** We know -for sure- that the error came from our recorder module or rrweb directly if these are true, so swallow it */\n    output.shouldSwallow = true\n    output.reason = REASON_RRWEB\n    if (isSecurityPolicyAPIError) output.reason += '-' + REASON_SECURITY_POLICY\n  } else if (!!isMaybeNrRecorder && isSecurityPolicyAPIError) {\n    /** We -suspect- that the error came from NR, so if it matches the exact case we know about, swallow it */\n    output.shouldSwallow = true\n    output.reason = REASON_RRWEB + '-' + REASON_SECURITY_POLICY\n  }\n  // other swallow conditions could also be added here\n  return output\n}\n","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { canonicalFunctionName } from './canonical-function-name'\nimport { computeStackTrace } from './compute-stack-trace'\nimport { stringHashCode } from './string-hash-code'\nimport { truncateSize } from './format-stack-trace'\n\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler'\nimport { stringify } from '../../../common/util/stringify'\nimport { handle } from '../../../common/event-emitter/handle'\nimport { globalScope } from '../../../common/constants/runtime'\n\nimport { FEATURE_NAME } from '../constants'\nimport { FEATURE_NAMES } from '../../../loaders/features/features'\nimport { AggregateBase } from '../../utils/aggregate-base'\nimport { now } from '../../../common/timing/now'\nimport { applyFnToProps } from '../../../common/util/traverse'\nimport { evaluateInternalError } from './internal-errors'\nimport { isContainerAgentTarget } from '../../../common/util/target'\nimport { warn } from '../../../common/util/console'\n\n/**\n * @typedef {import('./compute-stack-trace.js').StackInfo} StackInfo\n */\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME\n  constructor (agentRef) {\n    super(agentRef, FEATURE_NAME)\n\n    this.stackReported = {}\n    this.observedAt = {}\n    this.pageviewReported = {}\n    this.bufferedErrorsUnderSpa = {}\n    this.errorOnPage = false\n\n    // this will need to change to match whatever ee we use in the instrument\n    this.ee.on('interactionDone', (interaction, wasSaved) => this.onInteractionDone(interaction, wasSaved))\n\n    register('err', (...args) => this.storeError(...args), this.featureName, this.ee)\n    register('ierr', (...args) => this.storeError(...args), this.featureName, this.ee)\n    register('softNavFlush', (interactionId, wasFinished, softNavAttrs) =>\n      this.onSoftNavNotification(interactionId, wasFinished, softNavAttrs), this.featureName, this.ee) // when an ixn is done or cancelled\n\n    this.harvestOpts.aggregatorTypes = ['err', 'ierr', 'xhr'] // the types in EventAggregator this feature cares about\n\n    // 0 == off, 1 == on\n    this.waitForFlags(['err']).then(([errFlag]) => {\n      if (errFlag) {\n        this.drain()\n      } else {\n        this.blocked = true // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n        this.deregisterDrain()\n      }\n    })\n  }\n\n  serializer (aggregatorTypeToBucketsMap) {\n    return applyFnToProps(aggregatorTypeToBucketsMap, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string')\n  }\n\n  queryStringsBuilder (aggregatorTakeReturnedData) {\n    const qs = {}\n    const releaseIds = stringify(this.agentRef.runtime.releaseIds)\n    if (releaseIds !== '{}') qs.ri = releaseIds\n\n    if (aggregatorTakeReturnedData?.err?.length) {\n      if (!this.errorOnPage) {\n        qs.pve = '1'\n        this.errorOnPage = true\n      }\n      // For assurance, erase any `hasReplay` flag from all errors if replay is not recording, not-yet imported, or not running at all.\n      if (!this.agentRef.features?.[FEATURE_NAMES.sessionReplay]?.featAggregate?.replayIsActive()) aggregatorTakeReturnedData.err.forEach(error => delete error.params.hasReplay)\n    }\n    return qs\n  }\n\n  /**\n   * Builds a standardized stack trace string from the frames in the given `stackInfo` object, with each frame separated\n   * by a newline character. Lines take the form `<functionName>@<url>:<lineNumber>`.\n   *\n   * @param {StackInfo} stackInfo - An object specifying a stack string and individual frames.\n   * @returns {string} A canonical stack string built from the URLs and function names in the given `stackInfo` object.\n   */\n  buildCanonicalStackString (stackInfo) {\n    var canonicalStackString = ''\n\n    for (var i = 0; i < stackInfo.frames.length; i++) {\n      var frame = stackInfo.frames[i]\n      var func = canonicalFunctionName(frame.func)\n\n      if (canonicalStackString) canonicalStackString += '\\n'\n      if (func) canonicalStackString += func + '@'\n      if (typeof frame.url === 'string') canonicalStackString += frame.url\n      if (frame.line) canonicalStackString += ':' + frame.line\n    }\n\n    return canonicalStackString\n  }\n\n  /**\n   *\n   * @param {Error|UncaughtError} err The error instance to be processed\n   * @param {number} time the relative ms (to origin) timestamp of occurence\n   * @param {boolean=} internal if the error was \"caught\" and deemed \"internal\" before reporting to the jserrors feature\n   * @param {object=} customAttributes  any custom attributes to be included in the error payload\n   * @param {boolean=} hasReplay a flag indicating if the error occurred during a replay session\n   * @param {string=} swallowReason a string indicating pre-defined reason if swallowing the error.  Mainly used by the internal error SMs.\n   * @param {object=} target the target to buffer and harvest to, if undefined the default configuration target is used\n   * @returns\n   */\n  storeError (err, time, internal, customAttributes, hasReplay, swallowReason, targetEntityGuid) {\n    if (!err) return\n    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid)\n    if (!target) return warn(56, this.featureName)\n    // are we in an interaction\n    time = time || now()\n    let filterOutput\n\n    if (!internal && this.agentRef.runtime.onerror) {\n      filterOutput = this.agentRef.runtime.onerror(err)\n      if (filterOutput && !(typeof filterOutput.group === 'string' && filterOutput.group.length)) {\n        // All truthy values mean don't report (store) the error, per backwards-compatible usage,\n        // - EXCEPT if a fingerprinting label is returned, via an object with key of 'group' and value of non-empty string\n        return\n      }\n      // Again as with previous usage, all falsey values would include the error.\n    }\n\n    var stackInfo = computeStackTrace(err)\n\n    const { shouldSwallow, reason } = evaluateInternalError(stackInfo, internal, swallowReason)\n    if (shouldSwallow) {\n      this.reportSupportabilityMetric('Internal/Error/' + reason)\n      return\n    }\n\n    var canonicalStackString = this.buildCanonicalStackString(stackInfo)\n\n    const params = {\n      stackHash: stringHashCode(canonicalStackString),\n      exceptionClass: stackInfo.name,\n      request_uri: globalScope?.location.pathname\n    }\n    if (stackInfo.message) params.message = '' + stackInfo.message\n    // Notice if filterOutput isn't false|undefined OR our specified object, this func would've returned already (so it's unnecessary to req-check group).\n    // Do not modify the name ('errorGroup') of params without DEM approval!\n    if (filterOutput?.group) params.errorGroup = filterOutput.group\n\n    // Should only decorate \"hasReplay\" for the container agent, so check if the target matches the config\n    if (hasReplay && isContainerAgentTarget(target, this.agentRef)) params.hasReplay = hasReplay\n    /**\n     * The bucketHash is different from the params.stackHash because the params.stackHash is based on the canonicalized\n     * stack trace and is used downstream in NR1 to attempt to group the same errors across different browsers. However,\n     * the canonical stack trace excludes items like the column number increasing the hit-rate of different errors potentially\n     * bucketing and ultimately resulting in the loss of data in NR1.\n     */\n    var bucketHash = stringHashCode(`${stackInfo.name}_${stackInfo.message}_${stackInfo.stackString}_${params.hasReplay ? 1 : 0}`)\n\n    if (!this.stackReported[bucketHash]) {\n      this.stackReported[bucketHash] = true\n      params.stack_trace = truncateSize(stackInfo.stackString)\n      this.observedAt[bucketHash] = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time))\n    } else {\n      params.browser_stack_hash = stringHashCode(stackInfo.stackString)\n    }\n    params.releaseIds = stringify(this.agentRef.runtime.releaseIds)\n\n    // When debugging stack canonicalization/hashing, uncomment these lines for\n    // more output in the test logs\n    // params.origStack = err.stack\n    // params.canonicalStack = canonicalStack\n\n    if (!this.pageviewReported[bucketHash]) {\n      params.pageview = 1\n      this.pageviewReported[bucketHash] = true\n    }\n\n    params.firstOccurrenceTimestamp = this.observedAt[bucketHash]\n    params.timestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time))\n\n    var type = 'err'\n    var newMetrics = { time }\n\n    // Trace sends the error in its payload, and both trace & replay simply listens for any error to occur.\n    const jsErrorEvent = [type, bucketHash, params, newMetrics, customAttributes]\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) handle('trace-jserror', jsErrorEvent, undefined, FEATURE_NAMES.sessionTrace, this.ee)\n    // still send EE events for other features such as above, but stop this one from aggregating internal data\n    if (this.blocked) return\n\n    if (err?.__newrelic?.[this.agentIdentifier]) {\n      params._interactionId = err.__newrelic[this.agentIdentifier].interactionId\n      params._interactionNodeId = err.__newrelic[this.agentIdentifier].interactionNodeId\n    }\n\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) {\n      const softNavInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.softNav])\n      // Note: the following are subject to potential race cond wherein if the other feature aren't fully initialized, it'll be treated as there being no associated interaction.\n      // They each will also tack on their respective properties to the params object as part of the decision flow.\n      if (softNavInUse) handle('jserror', [params, time], undefined, FEATURE_NAMES.softNav, this.ee)\n      else handle('spa-jserror', jsErrorEvent, undefined, FEATURE_NAMES.spa, this.ee)\n\n      if (params.browserInteractionId && !params._softNavFinished) { // hold onto the error until the in-progress interaction is done, eithered saved or discarded\n        this.bufferedErrorsUnderSpa[params.browserInteractionId] ??= []\n        this.bufferedErrorsUnderSpa[params.browserInteractionId].push(jsErrorEvent)\n      } else if (params._interactionId != null) { // same as above, except tailored for the way old spa does it\n        this.bufferedErrorsUnderSpa[params._interactionId] = this.bufferedErrorsUnderSpa[params._interactionId] || []\n        this.bufferedErrorsUnderSpa[params._interactionId].push(jsErrorEvent)\n      } else {\n      // Either there is no interaction (then all these params properties will be undefined) OR there's a related soft navigation that's already completed.\n      // The old spa does not look up completed interactions at all, so there's no need to consider it.\n        this.#storeJserrorForHarvest(jsErrorEvent, params.browserInteractionId !== undefined, params._softNavAttributes)\n      }\n    }\n\n    // always add directly if scoped to a sub-entity, the other pathways above will be deterministic if the main agent should procede\n    if (targetEntityGuid) this.#storeJserrorForHarvest([...jsErrorEvent, targetEntityGuid], false, params._softNavAttributes)\n  }\n\n  #storeJserrorForHarvest (errorInfoArr, softNavOccurredFinished, softNavCustomAttrs = {}) {\n    let [type, bucketHash, params, newMetrics, localAttrs, targetEntityGuid] = errorInfoArr\n    const allCustomAttrs = {}\n\n    if (softNavOccurredFinished) {\n      Object.entries(softNavCustomAttrs).forEach(([k, v]) => setCustom(k, v)) // when an ixn finishes, it'll include stuff in jsAttributes + attrs specific to the ixn\n      bucketHash += params.browserInteractionId\n\n      delete params._softNavAttributes // cleanup temp properties from synchronous evaluation; this is harmless when async from soft nav (properties DNE)\n      delete params._softNavFinished\n    } else { // interaction was cancelled -> error should not be associated OR there was no interaction\n      Object.entries(this.agentRef.info.jsAttributes).forEach(([k, v]) => setCustom(k, v))\n      delete params.browserInteractionId\n    }\n    if (localAttrs) Object.entries(localAttrs).forEach(([k, v]) => setCustom(k, v)) // local custom attrs are applied in either case with the highest precedence\n\n    const jsAttributesHash = stringHashCode(stringify(allCustomAttrs))\n    const aggregateHash = bucketHash + ':' + jsAttributesHash\n\n    this.events.add([type, aggregateHash, params, newMetrics, allCustomAttrs], targetEntityGuid)\n\n    function setCustom (key, val) {\n      allCustomAttrs[key] = (val && typeof val === 'object' ? stringify(val) : val)\n    }\n  }\n\n  /**\n  * If the event lacks an entityGuid (the default behavior), the main agent should capture the data. If the data is assigned to a sub-entity target\n  * the main agent should not capture events unless it is configured to do so.\n  * @param {string} entityGuid - the context object for the event\n  * @returns {boolean} - whether the main agent should capture the event to its internal target\n  */\n  shouldAllowMainAgentToCapture (entityGuid) {\n    return (!entityGuid || this.agentRef.init.api.duplicate_registered_data)\n  }\n\n  // TO-DO: Remove this function when old spa is taken out. #storeJserrorForHarvest handles the work with the softnav feature.\n  onInteractionDone (interaction, wasSaved) {\n    if (!this.bufferedErrorsUnderSpa[interaction.id] || this.blocked) return\n\n    this.bufferedErrorsUnderSpa[interaction.id].forEach((item) => {\n      var allCustomAttrs = {}\n      const localCustomAttrs = item[4]\n\n      Object.entries(interaction.root.attrs.custom || {}).forEach(setCustom) // tack on custom attrs from the interaction\n      Object.entries(localCustomAttrs || {}).forEach(setCustom)\n\n      var params = item[2]\n      if (wasSaved) {\n        params.browserInteractionId = interaction.root.attrs.id\n        if (params._interactionNodeId) params.parentNodeId = params._interactionNodeId.toString()\n      }\n      delete params._interactionId\n      delete params._interactionNodeId\n\n      var hash = wasSaved ? item[1] + interaction.root.attrs.id : item[1]\n      var jsAttributesHash = stringHashCode(stringify(allCustomAttrs))\n      var aggregateHash = hash + ':' + jsAttributesHash\n\n      this.events.add([item[0], aggregateHash, params, item[3], allCustomAttrs], item[5])\n\n      function setCustom ([key, val]) {\n        allCustomAttrs[key] = (val && typeof val === 'object' ? stringify(val) : val)\n      }\n    })\n    delete this.bufferedErrorsUnderSpa[interaction.id]\n  }\n\n  onSoftNavNotification (interactionId, wasFinished, softNavAttrs) {\n    if (this.blocked) return\n\n    this.bufferedErrorsUnderSpa[interactionId]?.forEach(jsErrorEvent =>\n      this.#storeJserrorForHarvest(jsErrorEvent, wasFinished, softNavAttrs) // this should not modify the re-used softNavAttrs contents\n    )\n    delete this.bufferedErrorsUnderSpa[interactionId] // wipe the list of jserrors so they aren't duplicated by another call to the same id\n  }\n}\n"],"names":["canonicalFunctionNameRe","canonicalFunctionName","functionNameString","match","stripNewlinesRegex","MAX_STACK_TRACE_LENGTH","formatStackTrace","stackLines","truncateStackLines","stackString","truncatedLines","truncateSize","canonicalizeUrl","url","cleanedUrl","cleanURL","cleanedGlobalScopeUrl","initialLocation","classNameRegex","chrome","gecko","chromeEval","ieEval","computeStackTrace","ex","stack","computeStackTraceFromStackProp","computeStackTraceBySourceAndLine","computeStackTraceWithMessageOnly","errorInfo","parseStackProp","getClassName","info","line","element","getStackElement","isNrWrapper","canonicalUrl","parts","className","obj","results","functionName","stringHashCode","string","hash","charVal","i","REASON_RRWEB","REASON_SECURITY_POLICY","evaluateInternalError","stackInfo","internal","reason","output","leadingFrame","isNrRecorder","isRrweb","isMaybeNrRecorder","isSecurityPolicyAPIError","Aggregate","AggregateBase","FEATURE_NAME","agentRef","interaction","wasSaved","register","args","interactionId","wasFinished","softNavAttrs","errFlag","aggregatorTypeToBucketsMap","applyFnToProps","aggregatorTakeReturnedData","qs","releaseIds","stringify","FEATURE_NAMES","error","canonicalStackString","frame","func","err","time","customAttributes","hasReplay","swallowReason","targetEntityGuid","target","warn","now","filterOutput","shouldSwallow","params","globalScope","isContainerAgentTarget","bucketHash","type","newMetrics","jsErrorEvent","handle","#storeJserrorForHarvest","errorInfoArr","softNavOccurredFinished","softNavCustomAttrs","localAttrs","allCustomAttrs","k","v","setCustom","jsAttributesHash","aggregateHash","key","val","entityGuid","item","localCustomAttrs"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}