{"version":3,"file":"index-xx_AsTXw.js","sources":["../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/canonical-function-name.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/format-stack-trace.js","../../node_modules/@newrelic/browser-agent/dist/esm/common/url/canonicalize-url.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/compute-stack-trace.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/string-hash-code.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/internal-errors.js","../../node_modules/@newrelic/browser-agent/dist/esm/features/jserrors/aggregate/index.js"],"sourcesContent":["/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst canonicalFunctionNameRe = /([a-z0-9]+)$/i;\n\n/**\n * Given a function name string, extracts only an alphanumeric segment at the end of the string (if one exists).\n * This is useful for stack traces, where functions might not be named (e.g., anonymous, computed).\n *\n * @param {string} functionNameString - The original function name string.\n * @returns {string|undefined} The canonical function name, or undefined if the input is falsy or no alphanumeric segments are found.\n */\nexport function canonicalFunctionName(functionNameString) {\n  if (!functionNameString) return;\n  const match = functionNameString.match(canonicalFunctionNameRe);\n  if (match) return match[1];\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nvar stripNewlinesRegex = /^\\n+|\\n+$/g;\nvar MAX_STACK_TRACE_LENGTH = 65530;\nexport function formatStackTrace(stackLines) {\n  return truncateStackLines(stackLines).replace(stripNewlinesRegex, '');\n}\n\n// takes array of stack lines and returns string with top 50 and buttom 50 lines\nfunction truncateStackLines(stackLines) {\n  var stackString;\n  if (stackLines.length > 100) {\n    var truncatedLines = stackLines.length - 100;\n    stackString = stackLines.slice(0, 50).join('\\n');\n    stackString += '\\n< ...truncated ' + truncatedLines + ' lines... >\\n';\n    stackString += stackLines.slice(-50).join('\\n');\n  } else {\n    stackString = stackLines.join('\\n');\n  }\n  return stackString;\n}\n\n// truncates stack string to limit what is sent to backend\nexport function truncateSize(stackString) {\n  return stackString.length > MAX_STACK_TRACE_LENGTH ? stackString.substr(0, MAX_STACK_TRACE_LENGTH) : stackString;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { initialLocation } from '../constants/runtime';\nimport { cleanURL } from './clean-url';\n\n/**\n * Converts a URL to its basic form without a query string or fragment. If the resulting URL is the same as the\n * loader's origin URL, returns '<inline>'.\n * @param {string} url - The URL to be canonicalized.\n * @param {string} loaderOriginUrl - The origin URL of the agent loader, used for inline detection.\n * @returns {string} The canonicalized URL, or '<inline>' if the URL matches the loader origin URL.\n */\nexport function canonicalizeUrl(url) {\n  if (typeof url !== 'string') return '';\n  const cleanedUrl = cleanURL(url);\n  const cleanedGlobalScopeUrl = cleanURL(initialLocation);\n\n  // If the URL matches the origin URL of the loader, we assume it originated within an inline script.\n  if (cleanedUrl === cleanedGlobalScopeUrl) {\n    return '<inline>';\n  } else {\n    return cleanedUrl;\n  }\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable no-useless-escape */\n\n// computeStackTrace: cross-browser stack traces in JavaScript\n//\n// Syntax:\n//   s = computeStackTrace(exception) // consider using TraceKit.report instead\n// Returns:\n//   s.name              - exception name\n//   s.message           - exception message\n//   s.stack[i].url      - JavaScript or HTML file URL\n//   s.stack[i].func     - function name, or empty for anonymous functions\n//   s.stack[i].line     - line number, if known\n//   s.stack[i].column   - column number, if known\n//   s.stack[i].context  - an array of source code lines; the middle element corresponds to the correct line#\n//   s.mode              - 'stack', 'stacktrace', 'multiline', 'callers', 'onerror', or 'failed' -- method used to collect the stack trace\n//\n// Supports:\n//   - Firefox:  full stack trace with line numbers and unreliable column\n//               number on top frame\n//   - Chrome:   full stack trace with line and column numbers\n//   - Safari:   line and column number for the topmost stacktrace element\n//               only\n//   - IE:       no line numbers whatsoever\n\n// Contents of Exception in various browsers.\n//\n// SAFARI:\n// ex.message = Can't find variable: qq\n// ex.line = 59\n// ex.sourceId = 580238192\n// ex.sourceURL = http://...\n// ex.expressionBeginOffset = 96\n// ex.expressionCaretOffset = 98\n// ex.expressionEndOffset = 98\n// ex.name = ReferenceError\n//\n// FIREFOX:\n// ex.message = qq is not defined\n// ex.fileName = http://...\n// ex.lineNumber = 59\n// ex.stack = ...stack trace... (see the example below)\n// ex.name = ReferenceError\n//\n// CHROME:\n// ex.message = qq is not defined\n// ex.name = ReferenceError\n// ex.type = not_defined\n// ex.arguments = ['aa']\n// ex.stack = ...stack trace...\n//\n// INTERNET EXPLORER:\n// ex.message = ...\n// ex.name = ReferenceError\nimport { formatStackTrace } from './format-stack-trace';\nimport { canonicalizeUrl } from '../../../common/url/canonicalize-url';\nvar debug = false;\nvar classNameRegex = /function (.+?)\\s*\\(/;\nvar chrome = /^\\s*at (?:((?:\\[object object\\])?(?:[^(]*\\([^)]*\\))*[^()]*(?: \\[as \\S+\\])?) )?\\(?((?:file|http|https|chrome-extension):.*?)?:(\\d+)(?::(\\d+))?\\)?\\s*$/i;\nvar gecko = /^\\s*(?:(\\S*|global code)(?:\\(.*?\\))?@)?((?:file|http|https|chrome|safari-extension).*?):(\\d+)(?::(\\d+))?\\s*$/i;\nvar chromeEval = /^\\s*at .+ \\(eval at \\S+ \\((?:(?:file|http|https):[^)]+)?\\)(?:, [^:]*:\\d+:\\d+)?\\)$/i;\nvar ieEval = /^\\s*at Function code \\(Function code:\\d+:\\d+\\)\\s*/i;\n\n/**\n * Represents an error with a stack trace.\n * @typedef {Object} StackInfo\n * @property {string} name - The name of the error (e.g. 'TypeError').\n * @property {string} message - The error message.\n * @property {string} stackString - The stack trace as a string.\n * @property {Array<Object>} frames - An array of frames in the stack trace.\n * @property {string} frames.url - The URL of the file containing the code for the frame.\n * @property {string} frames.func - The name of the function associated with the frame.\n * @property {number} frames.line - The line number of the code in the frame.\n */\n\n/**\n * Attempts to compute a stack trace for the given exception.\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackInfo} A stack trace object containing information about the frames on the stack.\n */\nexport function computeStackTrace(ex) {\n  var stack = null;\n  try {\n    stack = computeStackTraceFromStackProp(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  try {\n    stack = computeStackTraceBySourceAndLine(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  try {\n    stack = computeStackTraceWithMessageOnly(ex);\n    if (stack) {\n      return stack;\n    }\n  } catch (e) {\n    if (debug) {\n      throw e;\n    }\n  }\n  return {\n    mode: 'failed',\n    stackString: '',\n    frames: []\n  };\n}\n\n/**\n * Computes stack trace information from the stack property. Chrome and Gecko use this property.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @return {?Object.<string, *>} Stack trace information.\n */\nfunction computeStackTraceFromStackProp(ex) {\n  if (!ex.stack) {\n    return null;\n  }\n  var errorInfo = ex.stack.split('\\n').reduce(parseStackProp, {\n    frames: [],\n    stackLines: [],\n    wrapperSeen: false\n  });\n  if (!errorInfo.frames.length) return null;\n  return {\n    mode: 'stack',\n    name: ex.name || getClassName(ex),\n    message: ex.message,\n    stackString: formatStackTrace(errorInfo.stackLines),\n    frames: errorInfo.frames\n  };\n}\n\n/**\n * Parses a line from a JavaScript error stack trace and adds it to the given `info` object.\n * Ignores all stack entries thrown from one of our wrapper functions.\n *\n * @param {object} info - The `info` object to add the parsed line to.\n * @param {string} line - The line to parse.\n * @returns {object} The `info` object with the parsed line added.\n */\nfunction parseStackProp(info, line) {\n  let element = getStackElement(line);\n\n  // This catches lines that aren't frames (like the first line stating the error).\n  if (!element) {\n    info.stackLines.push(line);\n    return info;\n  }\n\n  // Once we've seen a wrapper, ignore all subsequent stack entries.\n  if (isNrWrapper(element.func)) info.wrapperSeen = true;\n  if (!info.wrapperSeen) {\n    // Query strings and fragments should be removed, and URLs matching the loader's origin should be \"<inline>\".\n    let canonicalUrl = canonicalizeUrl(element.url);\n    if (canonicalUrl !== element.url) {\n      line = line.replace(element.url, canonicalUrl);\n      element.url = canonicalUrl;\n    }\n    info.stackLines.push(line);\n    info.frames.push(element);\n  }\n  return info;\n}\n\n/**\n * Parses a line from a JavaScript error stack trace to extract information about a stack trace element, such as the\n * URL, function name, line number, and column number.\n *\n * @param {string} line - A single line from a JavaScript error stack trace.\n * @returns {object} An object containing information about the stack trace element, including the URL, function\n *     name, line number, and column number (if available).\n */\nfunction getStackElement(line) {\n  var parts = line.match(gecko);\n  if (!parts) parts = line.match(chrome);\n  if (parts) {\n    return {\n      url: parts[2],\n      func: parts[1] !== 'Anonymous function' && parts[1] !== 'global code' && parts[1] || null,\n      line: +parts[3],\n      column: parts[4] ? +parts[4] : null\n    };\n  }\n  if (line.match(chromeEval) || line.match(ieEval) || line === 'anonymous') {\n    return {\n      func: 'evaluated code'\n    };\n  }\n}\n\n/**\n * Computes a stack trace object from an error object, by extracting the source and line number from the error object,\n * and using them to create a single stack frame.\n *\n * @param {Error} ex - The error object to compute the stack trace for.\n * @returns {Object|null} - An object representing the computed stack trace, or null if the\n * input error object does not contain a line number.\n */\nfunction computeStackTraceBySourceAndLine(ex) {\n  if (!('line' in ex)) return null;\n  var className = ex.name || getClassName(ex);\n\n  // Safari does not provide a URL for errors in eval'd code\n  if (!ex.sourceURL) {\n    return {\n      mode: 'sourceline',\n      name: className,\n      message: ex.message,\n      stackString: className + ': ' + ex.message + '\\n    in evaluated code',\n      frames: [{\n        func: 'evaluated code'\n      }]\n    };\n  }\n\n  // Remove any query string and fragment\n  var canonicalUrl = canonicalizeUrl(ex.sourceURL);\n  var stackString = className + ': ' + ex.message + '\\n    at ' + canonicalUrl;\n  if (ex.line) {\n    stackString += ':' + ex.line;\n    if (ex.column) {\n      stackString += ':' + ex.column;\n    }\n  }\n  return {\n    mode: 'sourceline',\n    name: className,\n    message: ex.message,\n    stackString,\n    frames: [{\n      url: canonicalUrl,\n      line: ex.line,\n      column: ex.column\n    }]\n  };\n}\n\n/**\n * For exceptions with no stack and only a message, derives a stack trace by extracting the class name and message.\n *\n * @param {Error} ex - The exception for which to compute the stack trace.\n * @returns {StackTrace} A stack trace object containing the name and message of the exception.\n */\nfunction computeStackTraceWithMessageOnly(ex) {\n  var className = ex.name || getClassName(ex);\n  if (!className) return null;\n  return {\n    mode: 'nameonly',\n    name: className,\n    message: ex.message,\n    stackString: className + ': ' + ex.message,\n    frames: []\n  };\n}\n\n/**\n * Attempts to extract the name of the constructor function (the class) of the given object.\n *\n * @param {Object} obj - The object for which to extract the constructor function name.\n * @returns {string} The name of the constructor function, or 'unknown' if the name cannot be determined.\n */\nfunction getClassName(obj) {\n  var results = classNameRegex.exec(String(obj.constructor));\n  return results && results.length > 1 ? results[1] : 'unknown';\n}\n\n/**\n * Checks whether the given function name is a New Relic wrapper function.\n *\n * @param {string} functionName - The name of the function to check.\n * @returns {boolean} True if the function name includes the string 'nrWrapper', false otherwise.\n */\nfunction isNrWrapper(functionName) {\n  return functionName && functionName.indexOf('nrWrapper') >= 0;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport function stringHashCode(string) {\n  var hash = 0;\n  var charVal;\n  if (!string || !string.length) return hash;\n  for (var i = 0; i < string.length; i++) {\n    charVal = string.charCodeAt(i);\n    hash = (hash << 5) - hash + charVal;\n    hash = hash | 0; // Convert to 32bit integer\n  }\n  return hash;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nconst REASON_RRWEB = 'Rrweb';\nconst REASON_SECURITY_POLICY = 'Security-Policy';\n/**\n * This function is responsible for determining if an error should be swallowed or not.\n * @param {Object} stackInfo - The error stack information.\n * @returns {boolean} - Whether the error should be swallowed or not.\n */\nexport function evaluateInternalError(stackInfo, internal, reason) {\n  const output = {\n    shouldSwallow: internal || false,\n    reason: reason || 'Other'\n  };\n  const leadingFrame = stackInfo.frames?.[0];\n  /** If we cant otherwise determine from the frames and message, the default of internal + reason will be the fallback */\n  if (!leadingFrame || typeof stackInfo?.message !== 'string') return output;\n\n  // check if the error happened in expected modules or if messages match known patterns\n  const isNrRecorder = leadingFrame?.url?.match(/nr-(.*)-recorder.min.js/);\n  const isRrweb = leadingFrame?.url?.match(/rrweb/);\n  const isMaybeNrRecorder = leadingFrame?.url?.match(/recorder/);\n  const isSecurityPolicyAPIError = stackInfo.message.toLowerCase().match(/an attempt was made to break through the security policy of the user agent/);\n\n  // check if modules and patterns above fit known swallow cases\n  if (!!isNrRecorder || !!isRrweb) {\n    /** We know -for sure- that the error came from our recorder module or rrweb directly if these are true, so swallow it */\n    output.shouldSwallow = true;\n    output.reason = REASON_RRWEB;\n    if (isSecurityPolicyAPIError) output.reason += '-' + REASON_SECURITY_POLICY;\n  } else if (!!isMaybeNrRecorder && isSecurityPolicyAPIError) {\n    /** We -suspect- that the error came from NR, so if it matches the exact case we know about, swallow it */\n    output.shouldSwallow = true;\n    output.reason = REASON_RRWEB + '-' + REASON_SECURITY_POLICY;\n  }\n  // other swallow conditions could also be added here\n  return output;\n}","/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { canonicalFunctionName } from './canonical-function-name';\nimport { computeStackTrace } from './compute-stack-trace';\nimport { stringHashCode } from './string-hash-code';\nimport { truncateSize } from './format-stack-trace';\nimport { registerHandler as register } from '../../../common/event-emitter/register-handler';\nimport { stringify } from '../../../common/util/stringify';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { globalScope } from '../../../common/constants/runtime';\nimport { FEATURE_NAME } from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { now } from '../../../common/timing/now';\nimport { applyFnToProps } from '../../../common/util/traverse';\nimport { evaluateInternalError } from './internal-errors';\nimport { isContainerAgentTarget } from '../../../common/util/target';\nimport { warn } from '../../../common/util/console';\n\n/**\n * @typedef {import('./compute-stack-trace.js').StackInfo} StackInfo\n */\n\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    this.stackReported = {};\n    this.observedAt = {};\n    this.pageviewReported = {};\n    this.bufferedErrorsUnderSpa = {};\n    this.errorOnPage = false;\n\n    // this will need to change to match whatever ee we use in the instrument\n    this.ee.on('interactionDone', (interaction, wasSaved) => this.onInteractionDone(interaction, wasSaved));\n    register('err', (...args) => this.storeError(...args), this.featureName, this.ee);\n    register('ierr', (...args) => this.storeError(...args), this.featureName, this.ee);\n    register('softNavFlush', (interactionId, wasFinished, softNavAttrs) => this.onSoftNavNotification(interactionId, wasFinished, softNavAttrs), this.featureName, this.ee); // when an ixn is done or cancelled\n\n    this.harvestOpts.aggregatorTypes = ['err', 'ierr', 'xhr']; // the types in EventAggregator this feature cares about\n\n    // 0 == off, 1 == on\n    this.waitForFlags(['err']).then(([errFlag]) => {\n      if (errFlag) {\n        this.drain();\n      } else {\n        this.blocked = true; // if rum response determines that customer lacks entitlements for spa endpoint, this feature shouldn't harvest\n        this.deregisterDrain();\n      }\n    });\n  }\n  serializer(aggregatorTypeToBucketsMap) {\n    return applyFnToProps(aggregatorTypeToBucketsMap, this.obfuscator.obfuscateString.bind(this.obfuscator), 'string');\n  }\n  queryStringsBuilder(aggregatorTakeReturnedData) {\n    const qs = {};\n    const releaseIds = stringify(this.agentRef.runtime.releaseIds);\n    if (releaseIds !== '{}') qs.ri = releaseIds;\n    if (aggregatorTakeReturnedData?.err?.length) {\n      if (!this.errorOnPage) {\n        qs.pve = '1';\n        this.errorOnPage = true;\n      }\n      // For assurance, erase any `hasReplay` flag from all errors if replay is not recording, not-yet imported, or not running at all.\n      if (!this.agentRef.features?.[FEATURE_NAMES.sessionReplay]?.featAggregate?.replayIsActive()) aggregatorTakeReturnedData.err.forEach(error => delete error.params.hasReplay);\n    }\n    return qs;\n  }\n\n  /**\n   * Builds a standardized stack trace string from the frames in the given `stackInfo` object, with each frame separated\n   * by a newline character. Lines take the form `<functionName>@<url>:<lineNumber>`.\n   *\n   * @param {StackInfo} stackInfo - An object specifying a stack string and individual frames.\n   * @returns {string} A canonical stack string built from the URLs and function names in the given `stackInfo` object.\n   */\n  buildCanonicalStackString(stackInfo) {\n    var canonicalStackString = '';\n    for (var i = 0; i < stackInfo.frames.length; i++) {\n      var frame = stackInfo.frames[i];\n      var func = canonicalFunctionName(frame.func);\n      if (canonicalStackString) canonicalStackString += '\\n';\n      if (func) canonicalStackString += func + '@';\n      if (typeof frame.url === 'string') canonicalStackString += frame.url;\n      if (frame.line) canonicalStackString += ':' + frame.line;\n    }\n    return canonicalStackString;\n  }\n\n  /**\n   *\n   * @param {Error|UncaughtError} err The error instance to be processed\n   * @param {number} time the relative ms (to origin) timestamp of occurence\n   * @param {boolean=} internal if the error was \"caught\" and deemed \"internal\" before reporting to the jserrors feature\n   * @param {object=} customAttributes  any custom attributes to be included in the error payload\n   * @param {boolean=} hasReplay a flag indicating if the error occurred during a replay session\n   * @param {string=} swallowReason a string indicating pre-defined reason if swallowing the error.  Mainly used by the internal error SMs.\n   * @param {object=} target the target to buffer and harvest to, if undefined the default configuration target is used\n   * @returns\n   */\n  storeError(err, time, internal, customAttributes, hasReplay, swallowReason, targetEntityGuid) {\n    if (!err) return;\n    const target = this.agentRef.runtime.entityManager.get(targetEntityGuid);\n    if (!target) return warn(56, this.featureName);\n    // are we in an interaction\n    time = time || now();\n    let filterOutput;\n    if (!internal && this.agentRef.runtime.onerror) {\n      filterOutput = this.agentRef.runtime.onerror(err);\n      if (filterOutput && !(typeof filterOutput.group === 'string' && filterOutput.group.length)) {\n        // All truthy values mean don't report (store) the error, per backwards-compatible usage,\n        // - EXCEPT if a fingerprinting label is returned, via an object with key of 'group' and value of non-empty string\n        return;\n      }\n      // Again as with previous usage, all falsey values would include the error.\n    }\n    var stackInfo = computeStackTrace(err);\n    const {\n      shouldSwallow,\n      reason\n    } = evaluateInternalError(stackInfo, internal, swallowReason);\n    if (shouldSwallow) {\n      this.reportSupportabilityMetric('Internal/Error/' + reason);\n      return;\n    }\n    var canonicalStackString = this.buildCanonicalStackString(stackInfo);\n    const params = {\n      stackHash: stringHashCode(canonicalStackString),\n      exceptionClass: stackInfo.name,\n      request_uri: globalScope?.location.pathname\n    };\n    if (stackInfo.message) params.message = '' + stackInfo.message;\n    // Notice if filterOutput isn't false|undefined OR our specified object, this func would've returned already (so it's unnecessary to req-check group).\n    // Do not modify the name ('errorGroup') of params without DEM approval!\n    if (filterOutput?.group) params.errorGroup = filterOutput.group;\n\n    // Should only decorate \"hasReplay\" for the container agent, so check if the target matches the config\n    if (hasReplay && isContainerAgentTarget(target, this.agentRef)) params.hasReplay = hasReplay;\n    /**\n     * The bucketHash is different from the params.stackHash because the params.stackHash is based on the canonicalized\n     * stack trace and is used downstream in NR1 to attempt to group the same errors across different browsers. However,\n     * the canonical stack trace excludes items like the column number increasing the hit-rate of different errors potentially\n     * bucketing and ultimately resulting in the loss of data in NR1.\n     */\n    var bucketHash = stringHashCode(\"\".concat(stackInfo.name, \"_\").concat(stackInfo.message, \"_\").concat(stackInfo.stackString, \"_\").concat(params.hasReplay ? 1 : 0));\n    if (!this.stackReported[bucketHash]) {\n      this.stackReported[bucketHash] = true;\n      params.stack_trace = truncateSize(stackInfo.stackString);\n      this.observedAt[bucketHash] = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n    } else {\n      params.browser_stack_hash = stringHashCode(stackInfo.stackString);\n    }\n    params.releaseIds = stringify(this.agentRef.runtime.releaseIds);\n\n    // When debugging stack canonicalization/hashing, uncomment these lines for\n    // more output in the test logs\n    // params.origStack = err.stack\n    // params.canonicalStack = canonicalStack\n\n    if (!this.pageviewReported[bucketHash]) {\n      params.pageview = 1;\n      this.pageviewReported[bucketHash] = true;\n    }\n    params.firstOccurrenceTimestamp = this.observedAt[bucketHash];\n    params.timestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctRelativeTimestamp(time));\n    var type = 'err';\n    var newMetrics = {\n      time\n    };\n\n    // Trace sends the error in its payload, and both trace & replay simply listens for any error to occur.\n    const jsErrorEvent = [type, bucketHash, params, newMetrics, customAttributes];\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) handle('trace-jserror', jsErrorEvent, undefined, FEATURE_NAMES.sessionTrace, this.ee);\n    // still send EE events for other features such as above, but stop this one from aggregating internal data\n    if (this.blocked) return;\n    if (err?.__newrelic?.[this.agentIdentifier]) {\n      params._interactionId = err.__newrelic[this.agentIdentifier].interactionId;\n      params._interactionNodeId = err.__newrelic[this.agentIdentifier].interactionNodeId;\n    }\n    if (this.shouldAllowMainAgentToCapture(targetEntityGuid)) {\n      const softNavInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.softNav]);\n      // Note: the following are subject to potential race cond wherein if the other feature aren't fully initialized, it'll be treated as there being no associated interaction.\n      // They each will also tack on their respective properties to the params object as part of the decision flow.\n      if (softNavInUse) handle('jserror', [params, time], undefined, FEATURE_NAMES.softNav, this.ee);else handle('spa-jserror', jsErrorEvent, undefined, FEATURE_NAMES.spa, this.ee);\n      if (params.browserInteractionId && !params._softNavFinished) {\n        // hold onto the error until the in-progress interaction is done, eithered saved or discarded\n        this.bufferedErrorsUnderSpa[params.browserInteractionId] ??= [];\n        this.bufferedErrorsUnderSpa[params.browserInteractionId].push(jsErrorEvent);\n      } else if (params._interactionId != null) {\n        // same as above, except tailored for the way old spa does it\n        this.bufferedErrorsUnderSpa[params._interactionId] = this.bufferedErrorsUnderSpa[params._interactionId] || [];\n        this.bufferedErrorsUnderSpa[params._interactionId].push(jsErrorEvent);\n      } else {\n        // Either there is no interaction (then all these params properties will be undefined) OR there's a related soft navigation that's already completed.\n        // The old spa does not look up completed interactions at all, so there's no need to consider it.\n        this.#storeJserrorForHarvest(jsErrorEvent, params.browserInteractionId !== undefined, params._softNavAttributes);\n      }\n    }\n\n    // always add directly if scoped to a sub-entity, the other pathways above will be deterministic if the main agent should procede\n    if (targetEntityGuid) this.#storeJserrorForHarvest([...jsErrorEvent, targetEntityGuid], false, params._softNavAttributes);\n  }\n  #storeJserrorForHarvest(errorInfoArr, softNavOccurredFinished, softNavCustomAttrs = {}) {\n    let [type, bucketHash, params, newMetrics, localAttrs, targetEntityGuid] = errorInfoArr;\n    const allCustomAttrs = {};\n    if (softNavOccurredFinished) {\n      Object.entries(softNavCustomAttrs).forEach(([k, v]) => setCustom(k, v)); // when an ixn finishes, it'll include stuff in jsAttributes + attrs specific to the ixn\n      bucketHash += params.browserInteractionId;\n      delete params._softNavAttributes; // cleanup temp properties from synchronous evaluation; this is harmless when async from soft nav (properties DNE)\n      delete params._softNavFinished;\n    } else {\n      // interaction was cancelled -> error should not be associated OR there was no interaction\n      Object.entries(this.agentRef.info.jsAttributes).forEach(([k, v]) => setCustom(k, v));\n      delete params.browserInteractionId;\n    }\n    if (localAttrs) Object.entries(localAttrs).forEach(([k, v]) => setCustom(k, v)); // local custom attrs are applied in either case with the highest precedence\n\n    const jsAttributesHash = stringHashCode(stringify(allCustomAttrs));\n    const aggregateHash = bucketHash + ':' + jsAttributesHash;\n    this.events.add([type, aggregateHash, params, newMetrics, allCustomAttrs], targetEntityGuid);\n    function setCustom(key, val) {\n      allCustomAttrs[key] = val && typeof val === 'object' ? stringify(val) : val;\n    }\n  }\n\n  /**\n  * If the event lacks an entityGuid (the default behavior), the main agent should capture the data. If the data is assigned to a sub-entity target\n  * the main agent should not capture events unless it is configured to do so.\n  * @param {string} entityGuid - the context object for the event\n  * @returns {boolean} - whether the main agent should capture the event to its internal target\n  */\n  shouldAllowMainAgentToCapture(entityGuid) {\n    return !entityGuid || this.agentRef.init.api.duplicate_registered_data;\n  }\n\n  // TO-DO: Remove this function when old spa is taken out. #storeJserrorForHarvest handles the work with the softnav feature.\n  onInteractionDone(interaction, wasSaved) {\n    if (!this.bufferedErrorsUnderSpa[interaction.id] || this.blocked) return;\n    this.bufferedErrorsUnderSpa[interaction.id].forEach(item => {\n      var allCustomAttrs = {};\n      const localCustomAttrs = item[4];\n      Object.entries(interaction.root.attrs.custom || {}).forEach(setCustom); // tack on custom attrs from the interaction\n      Object.entries(localCustomAttrs || {}).forEach(setCustom);\n      var params = item[2];\n      if (wasSaved) {\n        params.browserInteractionId = interaction.root.attrs.id;\n        if (params._interactionNodeId) params.parentNodeId = params._interactionNodeId.toString();\n      }\n      delete params._interactionId;\n      delete params._interactionNodeId;\n      var hash = wasSaved ? item[1] + interaction.root.attrs.id : item[1];\n      var jsAttributesHash = stringHashCode(stringify(allCustomAttrs));\n      var aggregateHash = hash + ':' + jsAttributesHash;\n      this.events.add([item[0], aggregateHash, params, item[3], allCustomAttrs], item[5]);\n      function setCustom([key, val]) {\n        allCustomAttrs[key] = val && typeof val === 'object' ? stringify(val) : val;\n      }\n    });\n    delete this.bufferedErrorsUnderSpa[interaction.id];\n  }\n  onSoftNavNotification(interactionId, wasFinished, softNavAttrs) {\n    if (this.blocked) return;\n    this.bufferedErrorsUnderSpa[interactionId]?.forEach(jsErrorEvent => this.#storeJserrorForHarvest(jsErrorEvent, wasFinished, softNavAttrs) // this should not modify the re-used softNavAttrs contents\n    );\n    delete this.bufferedErrorsUnderSpa[interactionId]; // wipe the list of jserrors so they aren't duplicated by another call to the same id\n  }\n}"],"names":["canonicalFunctionNameRe","canonicalFunctionName","functionNameString","match","stripNewlinesRegex","MAX_STACK_TRACE_LENGTH","formatStackTrace","stackLines","truncateStackLines","stackString","truncatedLines","truncateSize","canonicalizeUrl","url","cleanedUrl","cleanURL","cleanedGlobalScopeUrl","initialLocation","classNameRegex","chrome","gecko","chromeEval","ieEval","computeStackTrace","ex","stack","computeStackTraceFromStackProp","computeStackTraceBySourceAndLine","computeStackTraceWithMessageOnly","errorInfo","parseStackProp","getClassName","info","line","element","getStackElement","isNrWrapper","canonicalUrl","parts","className","obj","results","functionName","stringHashCode","string","hash","charVal","i","REASON_RRWEB","REASON_SECURITY_POLICY","evaluateInternalError","stackInfo","internal","reason","output","leadingFrame","isNrRecorder","isRrweb","isMaybeNrRecorder","isSecurityPolicyAPIError","Aggregate","AggregateBase","FEATURE_NAME","agentRef","interaction","wasSaved","register","args","interactionId","wasFinished","softNavAttrs","errFlag","aggregatorTypeToBucketsMap","applyFnToProps","aggregatorTakeReturnedData","qs","releaseIds","stringify","FEATURE_NAMES","error","canonicalStackString","frame","func","err","time","customAttributes","hasReplay","swallowReason","targetEntityGuid","target","warn","now","filterOutput","shouldSwallow","params","globalScope","isContainerAgentTarget","bucketHash","type","newMetrics","jsErrorEvent","handle","#storeJserrorForHarvest","errorInfoArr","softNavOccurredFinished","softNavCustomAttrs","localAttrs","allCustomAttrs","k","v","setCustom","jsAttributesHash","aggregateHash","key","val","entityGuid","item","localCustomAttrs"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}