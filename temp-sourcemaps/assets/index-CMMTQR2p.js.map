"/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { isPureObject } from '../../../common/util/type-check';\n\n/**\n * @typedef {object} GQLMetadata\n * @property {string} operationName Name of the operation\n * @property {string} operationType Type of the operation\n * @property {string} operationFramework Framework responsible for the operation\n */\n\n/**\n * Parses and returns the graphql metadata from a network request. If the network\n * request is not a graphql call, undefined will be returned.\n * @param {object|string} body Ajax request body\n * @param {string} query Ajax request query param string\n * @returns {GQLMetadata | undefined}\n */\nexport function parseGQL({\n  body,\n  query\n} = {}) {\n  if (!body && !query) return;\n  try {\n    const gqlBody = parseBatchGQL(parseGQLContents(body));\n    if (gqlBody) return gqlBody;\n    const gqlQuery = parseSingleGQL(parseGQLQueryString(query));\n    if (gqlQuery) return gqlQuery;\n  } catch (err) {\n    // parsing failed, return undefined\n  }\n}\n\n/**\n * @param {string|Object} gql The GraphQL object body sent to a GQL server\n * @returns {GQLMetadata}\n */\nfunction parseSingleGQL(contents) {\n  if (typeof contents !== 'object' || !contents.query || typeof contents.query !== 'string') return;\n\n  /** parses gql query string and returns [fullmatch, type match, name match] */\n  const matches = contents.query.trim().match(/^(query|mutation|subscription)\\s?(\\w*)/);\n  const operationType = matches?.[1];\n  if (!operationType) return;\n  const operationName = contents.operationName || matches?.[2] || 'Anonymous';\n  return {\n    operationName,\n    // the operation name of the indiv query\n    operationType,\n    // query, mutation, or subscription,\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseBatchGQL(contents) {\n  if (!contents) return;\n  if (!Array.isArray(contents)) contents = [contents];\n  const opNames = [];\n  const opTypes = [];\n  for (let content of contents) {\n    const operation = parseSingleGQL(content);\n    if (!operation) continue;\n    opNames.push(operation.operationName);\n    opTypes.push(operation.operationType);\n  }\n  if (!opTypes.length) return;\n  return {\n    operationName: opNames.join(','),\n    // the operation name of the indiv query -- joined by ',' for batched results\n    operationType: opTypes.join(','),\n    // query, mutation, or subscription -- joined by ',' for batched results\n    operationFramework: 'GraphQL'\n  };\n}\nfunction parseGQLContents(gqlContents) {\n  let contents;\n  if (!gqlContents || typeof gqlContents !== 'string' && typeof gqlContents !== 'object') return;else if (typeof gqlContents === 'string') contents = JSON.parse(gqlContents);else contents = gqlContents;\n  if (!isPureObject(contents) && !Array.isArray(contents)) return;\n  let isValid = false;\n  if (Array.isArray(contents)) isValid = contents.some(x => validateGQLObject(x));else isValid = validateGQLObject(contents);\n  if (!isValid) return;\n  return contents;\n}\nfunction parseGQLQueryString(gqlQueryString) {\n  if (!gqlQueryString || typeof gqlQueryString !== 'string') return;\n  const params = new URLSearchParams(gqlQueryString);\n  return parseGQLContents(Object.fromEntries(params));\n}\nfunction validateGQLObject(obj) {\n  return !(typeof obj !== 'object' || !obj.query || typeof obj.query !== 'string');\n}/**\n * Copyright 2020-2025 New Relic, Inc. All rights reserved.\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { registerHandler } from '../../../common/event-emitter/register-handler';\nimport { stringify } from '../../../common/util/stringify';\nimport { handle } from '../../../common/event-emitter/handle';\nimport { setDenyList, shouldCollectEvent } from '../../../common/deny-list/deny-list';\nimport { FEATURE_NAME } from '../constants';\nimport { FEATURE_NAMES } from '../../../loaders/features/features';\nimport { AggregateBase } from '../../utils/aggregate-base';\nimport { parseGQL } from './gql';\nimport { nullable, numeric, getAddStringContext, addCustomAttributes } from '../../../common/serialize/bel-serializer';\nexport class Aggregate extends AggregateBase {\n  static featureName = FEATURE_NAME;\n  constructor(agentRef) {\n    super(agentRef, FEATURE_NAME);\n    setDenyList(agentRef.runtime.denyList);\n    this.underSpaEvents = {};\n    const classThis = this;\n\n    // --- v Used by old spa feature\n    this.ee.on('interactionDone', (interaction, wasSaved) => {\n      if (!this.underSpaEvents[interaction.id]) return;\n      if (!wasSaved) {\n        // if the ixn was saved, then its ajax reqs are part of the payload whereas if it was discarded, it should still be harvested in the ajax feature itself\n        this.underSpaEvents[interaction.id].forEach(item => this.events.add(item));\n      }\n      delete this.underSpaEvents[interaction.id];\n    });\n    // --- ^\n    // --- v Used by new soft nav\n    registerHandler('returnAjax', event => this.events.add(event), this.featureName, this.ee);\n    // --- ^\n    registerHandler('xhr', function () {\n      // the EE-drain system not only switches \"this\" but also passes a new EventContext with info. Should consider platform refactor to another system which passes a mutable context around separately and predictably to avoid problems like this.\n      classThis.storeXhr(...arguments, this); // this switches the context back to the class instance while passing the NR context as an argument -- see \"ctx\" in storeXhr\n    }, this.featureName, this.ee);\n    this.waitForFlags([]).then(() => this.drain());\n  }\n  storeXhr(params, metrics, startTime, endTime, type, ctx) {\n    metrics.time = startTime;\n\n    // send to session traces\n    let hash;\n    if (params.cat) {\n      hash = stringify([params.status, params.cat]);\n    } else {\n      hash = stringify([params.status, params.host, params.pathname]);\n    }\n    const shouldCollect = shouldCollectEvent(params);\n    const shouldOmitAjaxMetrics = this.agentRef.init.feature_flags?.includes('ajax_metrics_deny_list');\n    const jserrorsInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.jserrors]);\n\n    // Report ajax timeslice metric (to be harvested by jserrors feature, but only if it's running).\n    if (jserrorsInUse && (shouldCollect || !shouldOmitAjaxMetrics)) {\n      this.agentRef.sharedAggregator?.add(['xhr', hash, params, metrics]);\n    }\n    if (!shouldCollect) {\n      if (params.hostname === this.agentRef.info.errorBeacon || this.agentRef.init.proxy?.beacon && params.hostname === this.agentRef.init.proxy.beacon) {\n        // This doesn't make a distinction if the same-domain request is going to a different port or path...\n        this.reportSupportabilityMetric('Ajax/Events/Excluded/Agent');\n        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/Agent');\n      } else {\n        this.reportSupportabilityMetric('Ajax/Events/Excluded/App');\n        if (shouldOmitAjaxMetrics) this.reportSupportabilityMetric('Ajax/Metrics/Excluded/App');\n      }\n      return; // do not send this ajax as an event\n    }\n    handle('bstXhrAgg', ['xhr', hash, params, metrics], undefined, FEATURE_NAMES.sessionTrace, this.ee); // have trace feature harvest AjaxNode\n\n    const event = {\n      method: params.method,\n      status: params.status,\n      domain: params.host,\n      path: params.pathname,\n      requestSize: metrics.txSize,\n      responseSize: metrics.rxSize,\n      type,\n      startTime,\n      endTime,\n      callbackDuration: metrics.cbTime\n    };\n    if (ctx.dt) {\n      event.spanId = ctx.dt.spanId;\n      event.traceId = ctx.dt.traceId;\n      event.spanTimestamp = Math.floor(this.agentRef.runtime.timeKeeper.correctAbsoluteTimestamp(ctx.dt.timestamp));\n    }\n\n    // parsed from the AJAX body, looking for operationName param & parsing query for operationType\n    event.gql = params.gql = parseGQL({\n      body: ctx.body,\n      query: ctx.parsedOrigin?.search\n    });\n    if (event.gql) this.reportSupportabilityMetric('Ajax/Events/GraphQL/Bytes-Added', stringify(event.gql).length);\n    const softNavInUse = Boolean(this.agentRef.features?.[FEATURE_NAMES.softNav]);\n    if (softNavInUse) {\n      // For newer soft nav (when running), pass the event to it for evaluation -- either part of an interaction or is given back\n      handle('ajax', [event], undefined, FEATURE_NAMES.softNav, this.ee);\n    } else if (ctx.spaNode) {\n      // For old spa (when running), if the ajax happened inside an interaction, hold it until the interaction finishes\n      const interactionId = ctx.spaNode.interaction.id;\n      this.underSpaEvents[interactionId] ??= [];\n      this.underSpaEvents[interactionId].push(event);\n    } else {\n      this.events.add(event);\n    }\n  }\n  serializer(eventBuffer) {\n    if (!eventBuffer.length) return;\n    const addString = getAddStringContext(this.agentRef.runtime.obfuscator);\n    let payload = 'bel.7;';\n    for (let i = 0; i < eventBuffer.length; i++) {\n      const event = eventBuffer[i];\n      const fields = [numeric(event.startTime), numeric(event.endTime - event.startTime), numeric(0),\n      // callbackEnd\n      numeric(0),\n      // no callbackDuration for non-SPA events\n      addString(event.method), numeric(event.status), addString(event.domain), addString(event.path), numeric(event.requestSize), numeric(event.responseSize), event.type === 'fetch' ? 1 : '', addString(0),\n      // nodeId\n      nullable(event.spanId, addString, true) +\n      // guid\n      nullable(event.traceId, addString, true) +\n      // traceId\n      nullable(event.spanTimestamp, numeric, false) // timestamp\n      ];\n      let insert = '2,';\n\n      // Since configuration objects (like info) are created new each time they are set, we have to grab the current pointer to the attr object here.\n      const jsAttributes = this.agentRef.info.jsAttributes;\n\n      // add custom attributes\n      // gql decorators are added as custom attributes to alleviate need for new BEL schema\n      const attrParts = addCustomAttributes({\n        ...(jsAttributes || {}),\n        ...(event.gql || {})\n      }, addString);\n      fields.unshift(numeric(attrParts.length));\n      insert += fields.join(',');\n      if (attrParts && attrParts.length > 0) {\n        insert += ';' + attrParts.join(';');\n      }\n      if (i + 1 < eventBuffer.length) insert += ';';\n      payload += insert;\n    }\n    return payload;\n  }\n}"